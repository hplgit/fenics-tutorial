========= Subdomains and boundary conditions =========
label{ch:subdomains}

idx{subdomains}

!bquote
So far, we have only looked briefly at how to specify boundary
conditions. In this chapter, we look more closely at how to specify
boundary conditions on specific parts (subdomains) of the boundary and
how to combine multiple boundary conditions. We will also look at how to
generate meshes with subdomains and how to define coefficients
with different values in different subdomains.
!equote

#========= Multiple domains and boundaries =========

======= Combining Dirichlet and Neumann conditions =======
label{ch:poisson0:DN}

Let's return to the Poisson problem from Chapter ref{ch:fundamentals}
and see how to extend the mathematics and the implementation to handle
a Dirichlet condition in combination with a Neumann condition. The
domain is still the unit square, but now we set the Dirichlet
condition $u=\ub$ at the left and right sides, $x=0$ and $x=1$, while
the Neumann condition

!bt
\begin{equation*}
-{\partial u\over\partial n}=g
\end{equation*}
!et
is applied to the remaining
sides $y=0$ and $y=1$.

#The Neumann condition is also known as a *natural boundary condition*
#(in contrast to an essential boundary condition).

idx{Neumann boundary condition}

===== PDE problem =====

Let $\GD$ and $\GN$ denote the parts of the boundary $\partial\Omega$
where the Dirichlet and Neumann conditions apply, respectively. The
complete boundary-value problem can be written as

!bt
\begin{alignat}{2}
    - \nabla^2 u &= f \quad&&\mbox{in } \Omega,  \\
    u &= \ub &&\mbox{on } \GD,       \\
    - {\partial u\over\partial n} &= g &&\mbox{on } \GN  \tp
\end{alignat}
!et
Again, we choose $u=1+x^2 + 2y^2$ as the exact solution and adjust $f$, $g$, and
$\ub$ accordingly:

!bt
\begin{align*}
f(x, y) &= -6,\\
g(x, y) &= \left\lbrace\begin{array}{ll}
0, & \quad y=0,\\
-4, & \quad y=1,
\end{array}\right.\\
\ub(x, y) &= 1 + x^2 + 2y^2\tp
\end{align*}
!et

For ease of programming, we define $g$ as a function over the whole
domain $\Omega$ such that $g$ takes on the correct values at $y=0$ and
$y=1$. One possible extension is

!bt
\begin{equation*}
g(x,y) = -4y\tp
\end{equation*}
!et

===== Variational formulation =====

The first task is to derive the variational formulation. This time we cannot
omit the boundary term arising from the integration by parts, because
$v$ is only zero on $\GD$. We have

!bt
\begin{equation*}
 -\int_\Omega (\nabla^2 u)v \dx
= \int_\Omega\nabla u\cdot\nabla v \dx - \int_{\partial\Omega}{\partial u\over
\partial n}v \ds,
\end{equation*}
!et
and since $v=0$ on $\GD$,

!bt
\begin{equation*}
- \int_{\partial\Omega}{\partial u\over
\partial n}v \ds
=
- \int_{\GN}{\partial u\over
\partial n}v \ds
= \int_{\GN}gv \ds,
\end{equation*}
!et
by applying the boundary condition on $\GN$.
The resulting weak form reads

!bt
\begin{equation}
\int_{\Omega} \nabla u \cdot \nabla v \dx
= \int_{\Omega} fv \dx - \int_{\GN} gv \ds\tp
label{ch:poisson0:2D:DN:weak}
\end{equation}
!et
Expressing this equation
in the standard notation $a(u,v)=L(v)$ is straightforward with

!bt
\begin{align}
a(u, v) &= \int_{\Omega} \nabla u \cdot \nabla v \dx,
label{ftut:poisson2:vard:a}\\
L(v) &= \int_{\Omega} fv \dx -
\int_{\GN} gv \ds\tp  label{ftut:poisson2:vard:L}
\end{align}
!et

===== FEniCS implementation =====

How does the Neumann condition impact the implementation?  Let us
revisit our previous implementation
"`${prog["poisson"]}.py`": "${src_url}/${prog["poisson"]}.py"
from ref[Section ref{ch:poisson0:impl}][ in cite{ftut1}][the section
"FEniCS implementation": "" in cite{ftut1}] and examine which changes
we need to make to incorporate the Neumann condition. It turns out
that only two changes are necessary:

  * The function `boundary` defining the Dirichlet boundary
    must be modified.
  * The new boundary term must be added to the expression for `L`.

The first adjustment can be coded as

!bc pycod
tol = 1E-14

def boundary_D(x, on_boundary):
    if on_boundary:
        if near(x[0], 0, tol) or near(x[0], 1, tol):
            return True
        else:
            return False
    else:
        return False
!ec
A more compact implementation reads

!bc pycod
def boundary_D(x, on_boundary):
    return on_boundary and (near(x[0], 0, tol) or near(x[0], 1, tol))
!ec

idx{`near`}

The second adjustment of our program concerns the definition of `L`,
which needs to include the Neumann condition:

!bc pycod
g = Expression('-4*x[1]', degree=1)
L = f*v*dx - g*v*ds
!ec
The `ds` variable implies a boundary integral, while `dx`
implies an integral over the domain $\Omega$.
No other modifications are necessary.

Note that the integration `*ds` is carried out over the entire
boundary, including the Dirichlet boundary. However, since the test
function `v` vanishes on the Dirichlet boundary (as a result
specifying a `DirichletBC`), the integral will only include the
contribution from the Neumann boundary.

!split
======= Setting multiple Dirichlet conditions =======
label{ch:poisson0:multiple:Dirichlet}

In the previous section, we used a single function $\ub(x,y)$ for
setting Dirichlet conditions on two parts of the boundary. Often it
is more practical to use multiple functions, one for each subdomain of the
boundary. Let us return to the case from Section ref{ch:poisson0:DN}
and redefine the problem in terms of two Dirichlet conditions:

!bt
\begin{alignat*}{2}
    - \nabla^2 u &= f \quad&&\mbox{in } \Omega, \\
    u &= u_{_\mathrm{L}} &&\mbox{on } \GD^{^{\mathrm{L}}}, \\
    u &= u_{_\mathrm{R}} &&\mbox{on } \GD^{^{\mathrm{R}}}, \\
    - {\partial u\over\partial n} &= g &&\mbox{on } \GN \tp
\end{alignat*}
!et
Here, $\GD^{^{\mathrm{L}}}$ is the left boundary $x=0$, while
$\GD^{^{\mathrm{R}}}$ is the right boundary $x=1$. We note that
$u_{_\mathrm{L}}(x, y) = 1 + 2y^2$,
$u_{_\mathrm{R}}(x, y) = 2 + 2y^2$, and
$g(x, y)=4y$.

For the boundary condition on $\GD^{^{\mathrm{L}}}$, we define the
usual triple of an expression for the boundary value, a function
defining the location of the boundary, and a `DirichletBC` object:

!bc pycod
u_L = Expression('1 + 2*x[1]*x[1]', degree=2)

def boundary_L(x, on_boundary):
    tol = 1E-14
    return on_boundary and near(x[0], 0, tol)

bc_L = DirichletBC(V, u_L, boundary_L)
!ec
For the boundary condition on $\GD^{^{\mathrm{R}}}$, we write a
similar code snippet:

!bc pycod
u_R = Expression('2 + 2*x[1]*x[1]', degree=2)

def boundary_R(x, on_boundary):
    tol = 1E-14
    return on_boundary and near(x[0], 1, tol)

bc_R = DirichletBC(V, u_R, boundary_R)
!ec
We collect the two boundary conditions in a list which
we can pass to the `solve` function to compute the solution:

!bc pycod
bcs = [bc_L, bc_R]
...
solve(a == L, u, bcs)
!ec

Note that for boundary values that do not depend on $x$ or $y$, we
might replace the `Expression` objects by `Constant` objects.

# #ifdef EXTRA
# We come to this in a minute with internal subdomains...

===== Classes for marking Dirichlet boundaries =====

idx{boundary markers}

Instead of using a function like `left_boundary(x, on_boundary)` to
mark a boundary, we can alternatively use a class, which allows
for more flexibility in more complicated problems. The class for marking
a boundary is derived from class `SubDomain` and has a method `inside(self, x, on_boundary)` for the code that returns whether the `point` is on the
boundary in question or not. Our previous `left_boundary` function
takes this form in its class version:

!bc pycod
class LeftBoundary(SubDomain):
    def inside(self, x, on_boundary):
        tol = 1E-14   # tolerance for coordinate comparisons
        return on_boundary and near(x[0], 0, tol)

left_boundary = LeftBoundary()
Gamma_0 = DirichletBC(V, u_L, left_boundary)
!ec
# #endif

!split
======= Defining subdomains for different materials =======
label{ftut:possion:2D:2mat:impl}

idx{heterogeneous media}
idx{multi-material domain}

Solving PDEs in domains made up of different materials is a frequently
encountered task. In FEniCS, these kinds of problems are handled by
defining subdomains inside the domain. A simple example with two
materials (subdomains) in 2D will demonstrate the idea. We consider
the following variable-coefficient extension of the Poisson equation
from Chapter ref{ch:fundamentals}:

!bt
\begin{equation} label{ch:poisson0:2D:2mat:varcoeff2}
  -\nabla \cdot \left\lbrack \kappa(x,y)\nabla u(x,y)\right\rbrack =
  f(x, y),
\end{equation}
!et
in some domain $\Omega$.
Physically, this problem may be viewed as a model of heat conduction,
with variable heat conductivity $\kappa(x, y) \geq
\underline{\kappa} > 0$.

For illustration purposes, we consider the domain $\Omega =
[0,1]\times [0,1]$ and divide it into two equal subdomains, as
depicted in Figure ref{fig:subdomains}:

!bt
\begin{equation*}
\Omega_0 = [0, 1]\times [0,1/2],\quad
\Omega_1 = [0, 1]\times (1/2,1]\tp
\end{equation*}
!et
We define $\kappa(x,y)=\kappa_0$ in $\Omega_0$ and $\kappa(x,y)=\kappa_1$ in $\Omega_1$,
where $\kappa_0, \kappa_1 > 0$ are given constants.

FIGURE: [fig/subdomains, width=400 frac=0.5] Two subdomains with different material parameters. label{fig:subdomains}

The variational formulation may be easily expressed in FEniCS as
follows:
!bc pycod
a = kappa*dot(grad(u), grad(v))*dx
L = f*v*dx
!ec
In the remainder of this section, we will discuss different strategies
for defining the coefficient `kappa` as an `Expression` that takes on
different values in the two subdomains.

===== Using expressions to define subdomains =====

The simplest way to implement a variable coefficient $\kappa =
\kappa(x, y)$ is to define an `Expression` which depends on the
coordinates $x$ and $y$. We have previously used the `Expression`
class to define expressions based on simple formulas. Aternatively,
an `Expression` can be defined as a Python class which allows for more
complex logic. The following code snippet illustrates this
construction:

!bc pycod
class K(Expression):
    def set_k_values(self, k_0, k_1):
        self.k_0, self.k_1 = k_0, k_1

    def eval(self, value, x):
        "Set value[0] to value at point x"
        tol = 1E-14
        if x[1] <= 0.5 + tol:
            value[0] = self.k_0
        else:
            value[0] = self.k_1

# Initialize kappa
kappa = K(degree=0)
kappa.set_k_values(1, 0.01)
!ec
The `eval` method gives great flexibility in defining functions, but a
downside is that FEniCS will call `eval` in Python for each node `x`,
which is a slow process.

An alternative method is to use a C++ string expression as we have
seen before, which is much more efficient in FEniCS. This can be done
using an inline if test:

!bc pycod
tol = 1E-14
k_0 = 1.0
k_1 = 0.01
kappa = Expression('x[1] <= 0.5 + tol ? k_0 : k_1', degree=0,
               tol=tol, k_0=k_0, k_1=k_1)
!ec

This method of defining variable coefficients works if the subdomains
are simple shapes that can be expressed in terms of geometric
inequalities. However, for more complex subdomains, we will need to
use a more general technique, as we will see next.

idx{boundary specification (class)}

===== Using mesh functions to define subdomains =====

idx{boundary markers}
idx{`MeshFunction`}
idx{`CellFunction`}
idx{`FacetFunction`}

We now address how to specify the subdomains $\Omega_0$ and $\Omega_1$
using a more general technique. This technique involves the use of two
classes that are essential in FEniCS when working with subdomains:
`SubDomain` and `MeshFunction`. Consider the following definition of the
boundary $x = 0$:

!bc pycod
def boundary(x, on_boundary):
    tol = 1E-14
    return on_boundary and near(x[0], 0, tol)
!ec
This boundary definition is actually a shortcut to the more general
FEniCS concept `SubDomain`. A `SubDomain` is a class which defines a
region in space (a subdomain) in terms of a member function `inside`
which returns `True` for points that belong to the subdomain and
`False` for points that don't belong to the subdomain. Here is how to
specify the boundary $x = 0$ as a `SubDomain`:

!bc pycod
class Boundary(SubDomain):
    def inside(self, x, on_boundary):
        tol = 1E-14
        return on_boundary and near(x[0], 0, tol)

boundary = Boundary()
bc = DirichletBC(V, Constant(0), boundary)
!ec
We notice that the `inside` function of the class `Boundary` is
(almost) identical to the previous boundary definition in terms of the
`boundary` function. Technically, our class `Boundary` is a
*subclass* of the FEniCS class `SubDomain`.

#A word about computer science terminology may be in order here: The term
#*instance* means a Python object of a particular type (such as
#`SubDomain`, `Function`, `FunctionSpace`, etc.).  Many use *instance*
#and *object* as interchangeable terms. In other computer programming
#languages one may also use the term *variable* for the same thing. We
#mostly use the well-known term *object* in this text.

We will use two `SubDomain` subclasses to define the two subdomains
$\Omega_0$ and $\Omega_1$:

!bc pycod
tol = 1E-14

class Omega_0(SubDomain):
    def inside(self, x, on_boundary):
        return x[1] <= 0.5 + tol

class Omega_1(SubDomain):
    def inside(self, x, on_boundary):
        return x[1] >= 0.5 - tol
!ec
Notice the use of `<=` and `>=` in both tests. FEniCS will call the
`inside` function for each vertex in a cell to determine whether or
not the cell belongs to a particular subdomain. For this reason, it is
important that the test holds for all vertices in cells aligned with
the boundary. In addition, we use a tolerance to make sure that
vertices on the internal boundary at $y = 0.5$ will belong to *both*
subdomains. This is a little counter-intuitive, but is necessary to
make the cells both above and below the internal boundary belong to
either $\Omega_0$ or $\Omega_1$.

To define the variable coefficient $\kappa$, we will use a powerful tool in
FEniCS called a `MeshFunction`. A `MeshFunction` is a discrete
function that can be evaluated at a set of so-called *mesh
entities*. A mesh entity in FEniCS is either a vertex, an edge, a
face, or a cell (triangle or tetrahedron). A `MeshFunction` over cells
is suitable to represent subdomains (materials), while a
`MeshFunction` over facets (edges or faces) is used to represent
pieces of external or internal boundaries. A `MeshFunction` over cells
can also be used to represent boundary markers for mesh refinement. A
FEniCS `MeshFunction` is parameterized both over its data type (like
integers or booleans) and its dimension (0 = vertex, 1 = edge
etc.). Special subclasses `VertexFunction`, `EdgeFunction` etc. are
provided for easy definition of a `MeshFunction` of a particular
dimension.

Since we need to define subdomains of $\Omega$ in the present example,
we make use of a `CellFunction`. The constructor
is given two arguments: (1) the type of value: `'int'` for integers,
`'size_t'` for non-negative (unsigned) integers, `'double'` for real
numbers, and `'bool'` for logical values; (2) a `Mesh` object.
Alternatively, the constructor can take just a filename and initialize
the `CellFunction` from data in a file.
#  #ifdef BOOK
We shall
demonstrate the file functionality in the next multi-material problem
in Section ref{ftut:possion:nD:nmat}.
#  #endif

We first create a `CellFunction` with non-negative
integer values (`'size_t'`):

!bc pycod
materials = CellFunction('size_t', mesh)
!ec

Next, we use the two subdomains to *mark* the cells belonging to each
subdomain:
!bc
subdomain_0 = Omega_0()
subdomain_1 = Omega_1()
subdomain_0.mark(materials, 0)
subdomain_1.mark(materials, 1)
!ec

This will set the values of the mesh function `materials` to $0$ on
each cell belonging to $\Omega_0$ and $1$ on all cells belonging to
$\Omega_1$. Alternatively, we can use the following equivalent code to
mark the cells:

!bc
materials.set_all(0)
subdomain_1.mark(materials, 1)
!ec
To examine the values of the mesh function and see that we have indeed
defined our subdomains correctly, we can simply plot the mesh
function:

!bc pycod
plot(materials, interactive=True)
!ec
We may also wish to store the values of the mesh function for later
use:
!bc pycod
File('materials.xml.gz') << materials
!ec
which can later be read back from file as follows:
!bc pycod
File('materials.xml.gz') >> materials
!ec

Now, to use the values of the mesh function `materials` to define the
variable coefficient $\kappa$, we create a FEniCS `Expression`:

!bc pycod
class K(Expression):
    def __init__(self, materials, k_0, k_1, **kwargs):
        self.materials = materials
        self.k_0 = k_0
        self.k_1 = k_1

def eval_cell(self, values, x, cell):
        if self.materials[cell.index] == 0:
            values[0] = self.k_0
        else:
            values[0] = self.k_1

kappa = K(materials, k_0, k_1, degree=0)
!ec

This is similar to the `Expression` subclass we defined above, but we
make use of the member function `eval_cell` in place of the regular
`eval` function. This version of the evaluation function has an
additional `cell` argument which we can use to check on which cell we
are currently evaluating the function.  We also defined the special
function `__init__` (the constructor) so that we can pass all data to
the `Expression` when it is created.

Since we make use of geometric tests to define the two `SubDomains`
for $\Omega_0$ and $\Omega_1$, the `MeshFunction` method may seem like
an unnecessary complication of the simple method using an
`Expression` with an if-test. However, in general the definition of
subdomains may be available as a `MeshFunction` (from a data file),
perhaps generated as part of the mesh generation process, and not as a
simple geometric test. In such cases the method demonstrated here is
the recommended way to work with subdomains.

idx{`CompiledSubDomain`}

# May not work if the dofs are renumbered
#===== Vectorized version of subdomain definitions =====
#
#To speed up this code, we can vectorize the expressions:
#
#!bc pycod
#materials = CellFunction('size_t', mesh)
#materials.set_all(0)  # "the rest"
#for m, subdomain in enumerate(subdomains[1:], 1):
#    subdomain.mark(materials, m)
#
#kappa_values = kappa
#V0 = FunctionSpace(mesh, 'DG', 0)
#kappa = Function(V0)
#help = np.asarray(materials.array(), dtype=np.int32)
#kappa.vector()[:] = np.choose(help, kappa_values)
#!ec
#The `help` array is required since `choose` cannot work with
#`materials.array()` because this array has elements of
#type `uint32`. We must therefore transform this array to an array
#`help` with standard `int32` integers.

===== Using C++ code snippets to define subdomains =====

The `SubDomain` and `Expression` Python classes are very convenient,
but their use leads to function calls from C++ to Python for each node
in the mesh. Since this involves a significant cost, we need to make
use of C++ code if performance is an issue.

Instead of writing the `SubDomain` subclass in Python, we may instead use
the `CompiledSubDomain` tool in FEniCS to specify the subdomain in C++
code and thereby speed up our code. Consider
the definition of the classes `Omega_0` and `Omega_1` above in Python. The
key strings that define these subdomains can be expressed in C++ syntax
and given as arguments to `CompiledSubDomain` as follows:

!bc pycod
tol = 1E-14
subdomain_0 = CompiledSubDomain('x[1] <= 0.5 + tol', tol=tol)
subdomain_1 = CompiledSubDomain('x[1] >= 0.5 - tol', tol=tol)
!ec
As seen, parameters can be specified using keyword arguments.
The resulting objects, `subdomain_0` and `subdomain_1`, can be used
as ordinary `SubDomain` objects.

Compiled subdomain strings can be applied for specifying boundaries as
well:

!bc pycod
boundary_R = CompiledSubDomain('on_boundary && near(x[0], 1, tol)',
                               tol=1E-14)
!ec

It is also possible to feed the C++ string (without parameters)
directly as the third argument to `DirichletBC` without explicitly
constructing a `CompiledSubDomain` object:

!bc pycod
bc1 = DirichletBC(V, value, 'on_boundary && near(x[0], 1, tol)')
!ec

Python `Expression` classes may also be redefined using C++ for more
efficient code. Consider again the definition of the class `K` above
for the variable coefficient $\kappa = \kappa(x)$. This may be redefined using a
C++ code snippet and the keyword `cppcode` to the regular FEniCS
`Expression` class:

!bc
cppcode = """
class K : public Expression
{
public:

  void eval(Array<double>& values,
            const Array<double>& x,
            const ufc::cell& cell) const
  {
    if ((*materials)[cell.index] == 0)
      values[0] = k_0;
    else
      values[0] = k_1;
  }

  std::shared_ptr<MeshFunction<std::size_t>> materials;
  double k_0;
  double k_1;

};
"""

kappa = Expression(cppcode=cppcode, degree=0)
kappa.materials = materials
kappa.k_0 = k_0
kappa.k_1 = k_1
!ec

% if EXV:
===== Exercise: Efficiency of Python vs C++ expressions =====
label{ch:poisson0:exer:eff:expression}
file=Expression_efficiency

Consider a cube mesh with $N$ cells in each spatial direction.
We want to define a `Function` on this mesh where the
values are given by the mathematical function $f(x,y,z)=a\sin(bxyz)$,
where $a$ and $b$ are two parameters. Write a `class SineXYZ`:

!bc pycod
class SineXYZ(Expression):
    def __init__(self, a, b):
        self.a, self.b = a, b

    def eval(self, value, x):
        value[0] = self.a*sin(self.b*x[0]*x[1]*x[2])
!ec
Create an alternative `Expression` based on giving the formula for $f(x,y,z)$
as a C++ code string. Compare the computational efficiency of the
two implementations (e.g., using `time.clock()` to measure the CPU time).

The `sin` function used in class `SineXYZ.eval` can mean many things.
This is an advanced FEniCS function if imported from `fenics`.
Much more efficient versions for sin of numbers are found in `math.sin`
and `numpy.sin`. Compare the use `sin` from `fenics`, `math`, `numpy`, and
`sympy` (note that `sin` from `sympy` is very slow).

!bsol
Here is an appropriate program:

@@@CODE exer/vol1/Expression_efficiency.py
Running the program shows that `sin` from `math` is the most efficient choice,
but a string C++ runs 40 times faster. Note that `fenics.sin`, which is a
sine function in the UFL language that can work with symbolic expressions
in finite element forms, is (naturally) less efficient than the `sin`
functions for numbers in `math` and `numpy`.
!esol
% endif

!split
======= Setting multiple Dirichlet, Neumann, and Robin conditions =======
label{ch:poisson0:multi:bc}
idx{Dirichlet boundary condition}
idx{Neumann boundary condition}
idx{Robin boundary condition}
idx{boundary conditions}

Consider again the variable-coefficient Poisson problem
from Section ref{ftut:possion:2D:2mat:impl}. We will now discuss
how to implement general combinations of boundary conditions of
Dirichlet, Neumann, and Robin type for this model problem.

===== Three types of boundary conditions =====

We extend our repertoire of boundary conditions to three types:
Dirichlet, Neumann, and Robin. Dirichlet conditions apply to some
parts $\GD^0, \GD^1, \ldots$, of the boundary:

!bt
\[ u = \ub^0\hbox{ on }\GD^0,\quad
   u = \ub^1\hbox{ on }\GD^1, \quad \ldots,\]
!et
where $\ub^i$ are prescribed functions, $i=0,1,\ldots$.
On other parts, $\GN^0, \GN^1, \ldots$, we have
Neumann conditions:

!bt
\[ -\kappa{\partial u\over\partial n} = g_{0}\hbox{ on }\GN^0,\quad
-\kappa{\partial u\over\partial n} = g_{1}\hbox{ on }\GN^1,\quad \ldots,
\]
!et
Finally, we have *Robin conditions*:

!bt
\begin{equation*}
-\kappa{\partial u\over\partial n} = r(u-s),
label{ch:poisson0:multi:bc:Robin}
\end{equation*}
!et
where $r$ and $s$ are specified functions.  The Robin condition is
most often used to model heat transfer to the surroundings and arise
naturally from Newton's cooling law. In that case, $r$ is a heat
transfer coefficient, and $s$ is the temperature of the
surroundings. Both can be space and time-dependent.
The Robin conditions apply
at some parts $\GR^0, \GR^1, \ldots$, of the boundary:

!bt
\[ -\kappa{\partial u\over\partial n} = r_0(u-s_0)\hbox{ on }\GR^0,\quad
-\kappa{\partial u\over\partial n} = r_1(u-s_1)\hbox{ on }\GR^1,\quad \ldots
\]
!et

===== PDE problem =====

With the notation above, the model problem to be solved with multiple
Dirichlet, Neumann, and Robin conditions can be formulated as follows:

!bt
\begin{alignat}{2}
-\nabla\cdot(\kappa\nabla u) &= f \quad&&\mbox{in } \Omega, label{ch:poisson0:2D:DN3}\\
u &= \ub^i &&\mbox{on } \GD^i,\quad i=0,1,\ldots
label{ch:poisson0:2D:DN3:bcD}\\
-\kappa{\partial u\over\partial n} &= g_i &&\mbox{on } \GN^i,\quad
i=0,1,\ldots
label{ch:poisson0:2D:DN3:bcN}\\
-\kappa{\partial u\over\partial n} &= r_i(u-s_i) \quad&&\mbox{on } \GR^i,\quad
i=0,1,\ldots
label{ch:poisson0:2D:DN3:bcR}
\end{alignat}
!et

===== Variational formulation =====

As usual, we multiply by a test function $v$ and integrate by parts:

!bt
\begin{equation*}
 -\int_\Omega \nabla\cdot(\kappa\nabla u) v \dx
= \int_\Omega \kappa\nabla u\cdot \nabla v \dx -
\int_{\partial\Omega}\kappa\frac{\partial u}{\partial n}v \ds\tp
\end{equation*}
!et
On the Dirichlet part of the boundary ($\GD^i$), the boundary integral
vanishes since $v = 0$. On the remaining part of the boundary, we
split the boundary integral into contributions from the Neumann parts
($\GN^i$) and Robin parts ($\GR^i$). Inserting the boundary conditions,
we obtain

!bt
\begin{align*}
-\int_{\partial\Omega} \kappa\frac{\partial u}{\partial n}v \ds
&=
-\sum_i\int_{\GN^i} \kappa\frac{\partial u}{\partial n} \ds
-\sum_i\int_{\GR^i} \kappa\frac{\partial u}{\partial n} \ds\\
&=
\sum_i\int_{\GN^i}g_i \ds +
\sum_i\int_{\GR^i}r_i(u-s_i) \ds\tp
\end{align*}
!et
We thus obtain the following variational problem:

!bt
\begin{equation}
F = \int_{\Omega} \kappa\nabla u\cdot \nabla v \dx +
\sum_i\int_{\GN^i} g_iv \ds +
\sum_i\int_{\GR^i}r_i(u-s_i)v \ds
- \int_{\Omega} fv \dx =0\tp
label{ch:poisson0:multi:bc:varform}
\end{equation}
!et

We have been used to writing this variational formulation in the
standard notation $a(u,v)=L(v)$, which requires that we identify all
integral depending on the trial function $u$, and collect these in
$a(u,v)$, while the remaining integrals go into $L(v)$. The integrals
from the Robin condition must for this reason be split into two parts:

!bt
\begin{equation*}
\int_{\GR^i}r_i(u-s_i)v \ds
= \int_{\GR^i} r_iuv \ds - \int_{\GR^i}r_is_iv \ds\tp
\end{equation*}
!et
We then have

!bt
\begin{align}
a(u, v) &= \int_{\Omega} \kappa\nabla u\cdot \nabla v \dx
+ \sum_i\int_{\GR^i}r_iuv \ds,
label{ch:poisson0:2D:DN3:var:a}\\
L(v) &= \int_{\Omega} fv \dx -
\sum_i\int_{\GN^i} g_i v \ds + \sum_i\int_{\GR^i}r_is_iv \ds\tp
label{ch:poisson0:2D:DN3:var:L}
\end{align}
!et
Alternatively, we may keep the formulation
(ref{ch:poisson0:multi:bc:varform}) and either solve the variational
problem as a nonlinear problem (`F == 0`) in FEniCS or use the FEniCS
functions `lhs` and `rhs` to extract the bilinear and linear parts of
`F`:

!bc pycod
a = lhs(F)
L = rhs(F)
!ec
Note that if we choose to solve this linear problem as a nonlinear
problem, the Newton iteration will converge in a single iteration.

## /usr/share/fenics/demo/documented/subdomains/python/demo_subdomains.py
## contains a good example, followed up in stokes solvers

===== FEniCS implementation =====

Let us examine how to extend our Poisson solver to handle general
combinations of Dirichlet, Neumann, and Robin boundary conditions.
Compared to our previous code, we must consider the following
extensions:

  * Defining markers for the different parts of the boundary.
  * Splitting the boundary integral into parts using the markers.

A general approach to the first task is to mark each of the desired
boundary parts with markers 0, 1, 2, and so forth. Here we aim at the
four sides of the unit square, marked with 0 ($x=0$), 1 ($x=1$), 2
($y=0$), and 3 ($y=1$).  The markers will be defined using a
`MeshFunction`, but contrary to Section
ref{ftut:possion:2D:2mat:impl}, this is not a function over cells, but
a function over the facets of the mesh. We use a `FacetFunction` for
this purpose:

!bc pycod
boundary_markers = FacetFunction('size_t', mesh)
!ec
As in Section ref{ftut:possion:2D:2mat:impl} we use a subclass of
`SubDomain` to identify the various parts of the mesh
function. Problems with domains of more complicated geometries may set
the mesh function for marking boundaries as part of the mesh
generation.  In our case, the boundary $x = 0$ can be marked
as follows:

!bc pycod
class BoundaryX0(SubDomain):
    tol = 1E-14
    def inside(self, x, on_boundary):
        return on_boundary and near(x[0], 0, tol)

bx0 = BoundaryX0()
bx0.mark(boundary_markers, 0)
!ec
Similarly, we create the classes `BoundaryX1` ($x=1$), `BoundaryY0`
($y=0$), and `BoundaryY1` ($y=1$) boundary, and mark these as
subdomains 1, 2, and 3, respectively.

For generality of the implementation, we let the user specify
what kind of boundary condition that applies to each of the four
boundaries. We set up a Python dictionary for this purpose, with
the key as subdomain number and the value as a dictionary specifying
the kind of condition as key and a function as its value.
For example,

!bc
boundary_conditions = {0: {'Dirichlet': u_D},
                       1: {'Robin':     (r, s)},
                       2: {'Neumann':   g},
                       3: {'Neumann',   0}}
!ec
specifies

 * a Dirichlet condition $u = \ub$ for $x = 0$;
 * a Robin condition $-\kappa\partial_n u = r(u-s)$ for $x = 1$;
 * a Neumann condition $-\kappa\partial_n u = g$ for $y = 0$;
 * a Neumann condition $-\kappa\partial_n u = 0$ for $y = 1$.

As explained in Section ref{ch:poisson0:multiple:Dirichlet}, multiple
Dirichlet conditions must be collected in a list of `DirichletBC`
objects. Based on the `boundary_conditions` data structure above, we
can construct this list by the following code snippet:

@@@CODE-4 vol1/python/poisson_extended.py from-to: # Collect Dirichlet@debug1

A new aspect of the variational problem is the two distinct
boundary integrals over $\GN^i$ and $\GR^i$.
Having a mesh function over exterior cell facets (our
`boundary_markers` object), where subdomains (boundary parts) are
numbered as $0,1,2,\ldots$, the special symbol `ds(0)`
implies integration over subdomain (part) 0, `ds(1)` denotes
integration over subdomain (part) 1, and so on.
The idea of multiple `ds`-type objects generalizes to volume
integrals too: `dx(0)`, `dx(1)`, etc., are used to
integrate over subdomain 0, 1, etc.,  inside $\Omega$.

To express integrals over the boundary parts using `ds(i)`, we must
first redefine the measure `ds` in terms of our boundary markers:

!bc pycod
ds = Measure('ds', domain=mesh, subdomain_data=boundary_markers)
!ec
Similarly, if we want integration over different parts of the domain,
we redefine `dx` as

!bc pycod
dx = Measure('dx', domain=mesh, subdomain_data=domain_markers)
!ec
where `domain_markers` is a `CellFunction` defining subdomains in $\Omega$.

Suppose we have a Robin condition with values `r` and `s` on subdomain
`R`, and a Neumann condition with value `g` on subdomain `N`. The
variational form can then be written

!bc pycod
a = kappa*dot(grad(u), grad(v))*dx + r*u*v*ds(R)
L = f*v*dx - g*v*ds(N) + r*s*v*ds(R)
!ec

In our case, things get a bit more complicated since the
information about integrals in Neumann and Robin conditions
are in the `boundary_conditions` data structure. We can collect
all Neumann conditions by the following code snippet:

@@@CODE-4 vol1/python/poisson_extended.py from-to: # Collect Neumann@# Collect Robin
Applying `sum(integrals_N)` will apply the `+` operator to
the variational forms in the `integrals_N` list and result
in the integrals we need for the right-hand side `L` of the
variational form.

The integrals in the Robin condition can similarly be collected
in lists:

@@@CODE-4 vol1/python/poisson_extended.py from-to: # Collect Robin@# Simpler Robin

We are now in a position to define the `a` and `L` expressions
in the variational formulation:

@@@CODE-4 vol1/python/poisson_extended.py from-to: # Sum integrals@# Simpler variational

idx{`lhs`}
idx{`rhs`}

Alternatively, we may use the FEniCS functions `lhs` and `rhs` as
mentioned above to simplify the extraction of terms for the Robin
integrals:

!bc pycod
integrals_R = []
for i in boundary_conditions:
    if 'Robin' in boundary_conditions[i]:
        r, s = boundary_conditions[i]['Robin']
        integrals_R.append(r*(u - s)*v*ds(i))

F = kappa*dot(grad(u), grad(v))*dx + \
    sum(integrals_R) - f*v*dx + sum(integrals_N)
a, L = lhs(F), rhs(F)
!ec
This time we can more naturally define the integrals from the
Robin condition as `r*(u - s)*v*ds(i)`.

The complete code can be found in the function
`solver_bcs` in the program
"`${prog["poisson_extended"]}.py`": "${src_url}/${prog["poisson_extended"]}.py".

idx{`${prog["poisson_extended"]}.py`}

===== Test problem =====

We will use the same exact solution $\uex=1+x^2+2y^2$ as in Chapter
ref{ch:fundamentals}, and thus take $\kappa=1$ and $f=-6$. Our domain
is the unit square, and we assign Dirichlet conditions at $x=0$ and
$x=1$, a Robin condition at $y=0$, and a Neumann condition at
$y=1$. With the given exact solution $\uex$, we realize that the
Neumann condition at $y=1$ is $-\partial u / \partial n = - \partial u /
\partial y = 4y = 4$, while the Robin condition at $y=0$ can be selected in
many ways. Since $-\partial u/\partial n=\partial u/\partial y=0$ at
$y=0$, we can select $s=\uex$ and specify $r \neq 0$ arbitrarily in the
Robin condition. We will set $r = 1000$ and $s = \uex$.

The boundary parts are thus $\GD^0$: $x=0$, $\GD^1$: $x=1$,
$\GR^0$: $y=0$, and $\GN^0$: $y=1$.

When implementing this test problem, and especially other test
problems with more complicated expressions, it is advantageous to use
symbolic computing. Below we define the exact solution as a `sympy`
expression and derive other functions from their mathematical
definitions.  Then we turn these expressions into C/C++ code, which
can then be used to define `Expression` objects.

@@@CODE-4 vol1/python/poisson_extended.py fromto: # Define manufactured solution in sympy and derive f, g, etc@# Compute solution

The complete code can be found in the function
`demo_bcs` in the program
"`${prog["poisson_extended"]}.py`": "${src_url}/${prog["poisson_extended"]}.py".

===== Debugging boundary conditions =====

It is easy to make mistakes when implementing a problem with many
different types of boundary conditions, as in the present case. One
method to debug boundary conditions is to run through all vertex
coordinates and check if the `SubDomain.inside` method marks the
vertex as on the boundary. Another useful method is to list which
degrees of freedom that are subject to Dirichlet conditions, and for
first-order Lagrange ($\mathsf{P}_1$) elements, print the
corresponding vertex coordinates as illustrated by the following
code snippet:

@@@CODE-4 vol1/python/poisson_extended.py fromto: if debug1:@# Define trial and test functions

!bnotice Calls to the `inside` method
In the code snippet above, we call the inside method for each
coordinate of the mesh. We could also place a printout inside the
`inside` method. Then it will be surprising to see that this method is
called not only for the points assoicated with degrees of freedom.
For $\mathsf{P}_1$ elements the method is also called for each
midpoint on each facet of the cells. This is because a Dirichlet
condition is by default set only if the entire facet can be said to be
subject to the condition defining the boundary.
!enotice

!split
======= Generating meshes with subdomains =======

So far, we have worked mostly with simple meshes (the unit square) and
defined boundaries and subdomains in terms of simple geometric tests
like $x = 0$ or $y \leq 0.5$. For more complex geometries, it is not
realistic to specify boundaries and subdomains in this way. Instead,
the boundaries and subdomains must be defined as part of the mesh
generation process. We will now look at how to use the FEniCS mesh
generation tool `mshr` to generate meshes and define subdomains.

===== PDE problem =====

idx{magnetostatics}
idx{Maxwell's equations}

We will again solve the Poisson equation, but this time for a
different application. Consider an iron cylinder with copper wires
wound around the cylinder as in Figure
ref{ftut1:fig:magnetostatics:geometry}. Through the copper wires a
static current $J = 1\,\mathrm{A}$ is flowing and we want to compute
the magnetic field $B$ in the iron cylinder, the copper wires, and the
surrounding vacuum.

FIGURE:[fig/magnetostatics_geometry, width=400 frac=0.5] Cross-section of an iron cylinder with copper wires wound around the cylinder, here with $n = 8$ windings. The inner circles are cross-sections of the copper wire coming up (``north'') and the outer circles are cross-sections of the copper wire going down into the plane (``south''). label{ftut1:fig:magnetostatics:geometry}

First, we simplify the problem to a 2D problem. We can do this by
assuming that the cylinder extends far along the $z$-axis and as a
consequence the field is virtually independent of the
$z$-coordinate. Next, we consider Maxwell's equation to derive a
Poisson equation for the magnetic field (or rather its potential):

!bt
\begin{align}
  \nabla\cdot  D &= \varrho, \\
  \nabla\cdot  B &= 0, \\
  \nabla\times E &= -\frac{\partial B}{\partial t}, \\
  \nabla\times H &= \frac{\partial D}{\partial t} + J.
\end{align}
!et
Here, $D$ is the displacement field, $B$ is the magnetic
field, $E$ is the electric field, and $H$ is the magnetizing field. In
addition to Maxwell's equations, we also need a constitutive relation
between $B$ and $H$,

!bt
\begin{equation}
  B = \mu H,
\end{equation}
!et
which holds for an isotropic linear magnetic medium. Here, $\mu$ is the
magnetic permeability of the material. Now, since $B$ is solenoidal
(divergence free) according to Maxwell's equations, we know that $B$
must be the curl of some vector field $A$. This field is called the
magnetic vector potential. Since the problem is static and thus
$\partial D/\partial t = 0$, it follows that

!bt
\begin{equation}
  J = \nabla \times H
    = \nabla \times (\mu^{-1} B)
    = \nabla \times (\mu^{-1} \nabla \times A)
    = -\nabla \cdot (\mu^{-1} \nabla A).
\end{equation}
!et
In the last step, we have expanded the second derivatives and used the
gauge freedom of $A$ to simplify the equations to a simple
vector-valued Poisson problem for the magnetic vector potential; if $B
= \nabla \times A$, then $B = \nabla \times (A + \nabla \psi)$ for any
scalar field $\psi$ (the gauge function). For the current problem, we
thus need to solve the following 2D Poisson problem for the
$z$-component $A_z$ of the magnetic vector potential:

!bt
\begin{align}
  - \nabla \cdot (\mu^{-1} \nabla A_z) &= J_z \quad \text{in } \Real^2, \\
  \lim_{|(x, y)| \rightarrow \infty} A_z &= 0.
\end{align}
!et
Since we cannot solve this problem on an infinite domain, we will
truncate the domain using a large disk and set $A_z = 0$ on the
boundary. The current $J_z$ is set to $+1\,\mathrm{A}$ in the interior
set of circles (copper wire cross-sections) and to $-1\,\mathrm{A}$ in
the exterior set of circles in Figure ref{ftut1:fig:magnetostatics:geometry}.

idx{infinite domain}

Once the magnetic vector potential has been computed, we can
compute the magnetic field $B = B(x, y)$ by

!bt
\begin{align}
  B(x, y) =
  \left(\frac{\partial A_z}{\partial y},
       -\frac{\partial A_z}{\partial x}\right).
\end{align}
!et

===== Variational formulation =====

The variational problem is derived as before by multiplying the PDE
with a test function $v$ and integrating by parts. Since the boundary
integral vanishes due to the Dirichlet condition, we obtain

!bt
\begin{equation}
  \int_{\Omega} \mu^{-1} \nabla A_z \cdot \nabla v \dx
  = \int_{\Omega} J_z v \dx,
\end{equation}
!et
or, in other words, $a(A_z, v) = L(v)$ with

!bt
\begin{align}
  a(A_z, v) &= \int_{\Omega} \mu^{-1} \nabla A_z \cdot \nabla v \dx, \\
  L(v) &= \int_{\Omega} J_z v \dx.
\end{align}
!et

===== FEniCS implementation =====

The first step is to generate a mesh for the geometry described in
Figure ref{ftut1:fig:magnetostatics:geometry}. We let $a$ and $b$ be the
inner and outer radii of the iron cylinder and let $c_1$ and $c_2$
be the radii of the two concentric distributions of copper wire
cross-sections. Furthermore, we let $r$ be the radius of a copper
wire, $R$ be the radius of our domain, and $n$ be the number of
windings (giving a total of $2n$ copper-wire cross-sections). This
geometry can be described easily using `mshr` and a little bit of
Python programming:

idx{mshr}
idx{`Circle`}
idx{`generate_mesh`}
idx{mesh generation}

!bc pycod
# Define geometry for background
domain = Circle(Point(0, 0), R)

# Define geometry for iron cylinder
cylinder = Circle(Point(0, 0), b) - Circle(Point(0, 0), a)

# Define geometry for wires (N = North (up), S = South (down))
angles_N = [i*2*pi/n for i in range(n)]
angles_S = [(i + 0.5)*2*pi/n for i in range(n)]
wires_N = [Circle(Point(c_1*cos(v), c_1*sin(v)), r) for v in angles_N]
wires_S = [Circle(Point(c_2*cos(v), c_2*sin(v)), r) for v in angles_S]
!ec

The mesh that we generate will be a mesh of the entire disk with
radius $R$ but we need the mesh generation to respect the internal
boundaries defined by the iron cylinder and the copper wires. We also
want `mshr` to label the subdomains so that we can easily specify
material parameters ($\mu$) and currents. To do this, we use the
`mshr` function `set_subdomain` as follows:

!bc pycod
# Set subdomain for iron cylinder
domain.set_subdomain(1, cylinder)

# Set subdomains for wires
for (i, wire) in enumerate(wires_N):
    domain.set_subdomain(2 + i, wire)
for (i, wire) in enumerate(wires_S):
    domain.set_subdomain(2 + n + i, wire)
!ec
Once the subdomains have been created, we can generate the mesh:

!bc pycod
mesh = generate_mesh(domain, 32)
!ec
A detail of the mesh is shown in Figure
ref{ftut1:fig:magnetostatics:mesh}.

FIGURE:[fig/magnetostatics_mesh, width=800 frac=0.95] Plot of (part of) the mesh generated for the magnetostatics test problem. The subdomains for the iron cylinder and copper wires are clearly visible. label{ftut1:fig:magnetostatics:mesh}

The mesh generated with `mshr` will contain information about the
subdomains we have defined. To use this information in the definition of
our variational problem and subdomain-dependent parameters, we will need to
create a `MeshFunction` that marks the subdomains. This can be easily
created by a call to the member function `mesh.domains`, which holds
the subdomain data generated by `mshr`:

!bc pycod
markers = MeshFunction('size_t', mesh, 2, mesh.domains())
!ec
This line creates a `MeshFunction` with unsigned integer values (the
subdomain numbers) with dimension 2, which is the cell dimension for
this 2D problem.

We can now use the markers as we have done before to redefine the
integration measure `dx`:

idx{`Measure`}

!bc pycod
dx = Measure('dx', domain=mesh, subdomain_data=markers)
!ec
Integrals over subdomains can then be expressed by `dx(0)`, `dx(1)`,
and so on. We use this to define the current $J_z = \pm 1\,\mathrm{A}$
in the copper wires:

!bc pycod
J_N = Constant(1.0)
J_S = Constant(-1.0)
A_z = TrialFunction(V)
v = TestFunction(V)
a = (1 / mu)*dot(grad(A_z), grad(v))*dx
L_N = sum(J_N*v*dx(i) for i in range(2, 2 + n))
L_S = sum(J_S*v*dx(i) for i in range(2 + n, 2 + 2*n))
L = L_N + L_S
!ec

The permeability is defined as an `Expression` that depends on the
subdomain number:
!bc
class Permeability(Expression):
    def __init__(self, markers, **kwargs):
        self.markers = markers
    def eval_cell(self, values, x, cell):
        if self.markers[cell.index] == 0:
            values[0] = 4*pi*1e-7 # vacuum
        elif self.markers[cell.index] == 1:
            values[0] = 1e-5      # iron (should really be 6.3e-3)
        else:
            values[0] = 1.26e-6   # copper

mu = Permeability(markers, degree=1)
!ec
As seen in this code snippet, we have used a somewhat less extreme
value for the magnetic permeability of iron. This is to make the
solution a little more interesting. It would otherwise be completely
dominated by the field in the iron cylinder.

Finally, when $A_z$ has been computed, we can compute the magnetic
field:

!bc pycod
W = VectorFunctionSpace(mesh, 'P', 1)
B = project(as_vector((A_z.dx(1), -A_z.dx(0))), W)
!ec
We use `as_vector` to interpret
`(A_z.dx(1), -A_z.dx(0))` as a vector in the sense of the UFL
form language, and not as a Python tuple. The resulting plots of the
magnetic vector potential and magnetic field are shown in Figures
ref{ftut1:fig:magnetostatics:potential} and
ref{ftut1:fig:magnetostatics:field}.

FIGURE:[fig/magnetostatics_potential, width=800 frac=0.95] Plot of the $z$-component $A_z$ of the magnetic vector potential. label{ftut1:fig:magnetostatics:potential}

FIGURE:[fig/magnetostatics_field, width=600 frac=0.75] Plot of the magnetic field $B$ in the $xy$-plane. label{ftut1:fig:magnetostatics:field}

The complete code for computing the magnetic field follows below.

@@@CODE vol1/python/magnetostatics.py fromto: from fenics import@
This example program can be found in the file "`${prog["magnetostatics"]}.py`": "${src_url}/${prog["magnetostatics"]}.py".

idx{`${prog["magnetostatics"]}.py`}
