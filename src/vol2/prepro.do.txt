======= Transforming hypercube domains =======
label{ftut:prepro}

The uniform hypercube domains produced by functions like
`UnitIntervalMesh`, `UnitSquareMesh`, `UnitCubeMesh`, `IntervalMesh`,
`RectangleMesh`, and `BoxMesh` can with simple mathematical means
be transformed to other shapes, or coordinates can be stretched
to provide a better resolution.

idx{mesh transformations}
idx{coordinate stretching}
idx{coordinate transformations}

===== Coordinate stretching =====

A mesh that is denser toward a boundary is often desired to increase
accuracy in that region. Given a mesh with uniformly spaced
coordinates $x_0,\ldots,x_{M-1}$ in $[a,b]$, the coordinate transformation
$\xi = (x-a)/(b-a)$ maps $x$ onto $\xi\in [0,1]$. A new mapping
$\eta = \xi^s$, for some $s>1$, stretches the mesh toward $\xi=0$ ($x=a$),
while $\eta = \xi^{1/s}$ makes a stretching toward $\xi=1$ ($x=b$).
Mapping the $\eta\in[0,1]$ coordinates back to $[a,b]$ gives new,
stretched $x$ coordinates,

!bt
\begin{equation}
\bar x = a + (b-a)\left({x-a\over b-a}\right)^s
\end{equation}
!et
toward $x=a$, or

!bt
\begin{equation}
\bar x = a + (b-a)\left({x-a\over b-a}\right)^{1/s}
\end{equation}
!et
toward $x=b$. Figure ref{ftut:mesh:transform:cyl:fig1} shows the
effect of making a rectangular mesh denser toward $x=0$ (prior to
the coordinate transformation below).

===== Rectangle to hollow circle mapping =====

One way of creating more complex geometries is to transform the
vertex coordinates in a rectangular mesh according to some formula.
Say we want to create a part of a hollow cylinder of $\Theta$ degrees,
with inner radius $a$ and outer radius $b$. A standard mapping from polar
coordinates to Cartesian coordinates can be used to generate the
hollow cylinder. Given a rectangle in $(\bar x, \bar y)$ space such that
$a\leq \bar x\leq b$ and $0\leq \bar y\leq 1$, the mapping

!bt
\begin{equation*}
\hat x = \bar x\cos (\Theta \bar y),\quad \hat y = \bar x\sin (\Theta \bar y),
\end{equation*}
!et
takes a point in the rectangular $(\bar x,\bar y)$
geometry and maps it to a point
$(\hat x, \hat y)$ in a hollow cylinder.

The corresponding Python code for first stretching the mesh and
then mapping it onto a hollow cylinder looks as follows:

!bc pycod
Theta = pi/2
a, b = 1, 5.0
nr = 10  # divisions in r direction
nt = 20  # divisions in theta direction
mesh = RectangleMesh(a, 0, b, 1, nr, nt, 'crossed')

# First make a denser mesh towards r=a
x = mesh.coordinates()[:,0]
y = mesh.coordinates()[:,1]
s = 1.3

def denser(x, y):
    return [a + (b-a)*((x-a)/(b-a))**s, y]

x_bar, y_bar = denser(x, y)
xy_bar_coor = numpy.array([x_bar, y_bar]).transpose()
mesh.coordinates()[:] = xy_bar_coor
plot(mesh, title='stretched mesh')

def cylinder(r, s):
    return [r*numpy.cos(Theta*s), r*numpy.sin(Theta*s)]

x_hat, y_hat = cylinder(x_bar, y_bar)
xy_hat_coor = numpy.array([x_hat, y_hat]).transpose()
mesh.coordinates()[:] = xy_hat_coor
plot(mesh, title='hollow cylinder')
interactive()
!ec
The result of calling `denser` and `cylinder` above is a list of two
vectors, with the $x$ and $y$ coordinates, respectively.
Turning this list into a `numpy` array object results in a $2\times M$
array, $M$ being the number of vertices in the mesh. However,
`mesh.coordinates()` is by a convention an $M\times 2$ array so we
need to take the transpose. The resulting mesh is displayed
in Figure ref{ftut:mesh:transform:cyl:fig1}.

FIGURE:[fig/hollow_cylinder, width=480] Hollow cylinder generated by mapping a rectangular mesh, stretched toward the left side. label{ftut:mesh:transform:cyl:fig1}

Setting boundary conditions in meshes created from mappings like the one
illustrated above is most conveniently done by using a mesh function
to mark parts of the boundary. The marking is easiest to perform
before the mesh is mapped since one can then conceptually work with
the sides in a pure rectangle.
# Stretch coordinates according to Mikael.
# Use refine uniformly and adaptively (adaptive poisson demo, use just
# grad u for example)
# Check ../../dielectric/python/demo.py og MeshEditor!
# Use refine og move.
#
# CHeck Netgen examples in the source, 2D.

# Transfinite mappings? Laplace?
