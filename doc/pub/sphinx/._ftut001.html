<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Fundamentals</title>
    
    <link rel="stylesheet" href="_static/fenics.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '1.1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

        <script src="http://sagecell.sagemath.org/static/jquery.min.js"></script>
        <script src="http://sagecell.sagemath.org/static/embedded_sagecell.js"></script>

        <script>sagecell.makeSagecell({inputLocation: ".sage"});</script>

        <style type="text/css">
                .sagecell .CodeMirror-scroll {
                        overflow-y: hidden;
                        overflow-x: auto;
                }
                .sagecell .CodeMirror {
                        height: auto;
                }
        </style>

    
    <link rel="top" title="FEniCS Tutorial" href="index.html" />
    <link rel="next" title="Time-dependent problems" href="._ftut002.html" />
    <link rel="prev" title="FEniCS Tutorial" href="._ftut000.html" />

<!--[if lte IE 6]>
<link rel="stylesheet" href="_static/ie6.css" type="text/css" media="screen" charset="utf-8" />
<![endif]-->

<link rel="stylesheet" href="_static/featured.css">
<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.5.1/jquery.min.js"></script>
<script src="_static/slides.min.jquery.js"></script>
  <script>
	$(function(){
		$('#products').slides({
			preload: true,
			preloadImage: 'img/loading.gif',
			effect: 'slide, fade',
			crossfade: true,
			slideSpeed: 350,
			fadeSpeed: 500,
			generateNextPrev: true,
			generatePagination: false,
	                play: 5000,
                        hoverPause: false,
                        animationStart: function(current){
				$('.caption').animate({
					bottom:-35
				},100);
				if (window.console && console.log) {
					// example return of current slide number
					console.log('animationStart on slide: ', current);
				};
			},
			animationComplete: function(current){
				$('.caption').animate({
					bottom:0
				},200);
				if (window.console && console.log) {
					// example return of current slide number
					console.log('animationComplete on slide: ', current);
				};
			},
			slidesLoaded: function() {
				$('.caption').animate({
					bottom:0
				},200);
			}
		});
	});
  </script>


<link rel="shortcut icon" href="_static/fenics.ico" />


  
       <style type="text/css">
         div.admonition {
           background-color: whiteSmoke;
           border: 1px solid #bababa;
         }
       </style>
      </head>
    
  <body role="document">
<div class="wrapper">
  <a href="http://fenicsproject.org/"><img src="_static/fenics_banner.png" width="900px" alt="FEniCS Project Banner" /></a>
  <div id="access">
    <div class="menu">
      <ul>
	<li><a href="._ftut000.html" title="Previous page"><font color="red">Prev</font></a></li>
	<li><a href="._ftut002.html" title="Next page"><font color="red">Next</font></a></li>
	<li class="page_item"><a href="index.html" title="Table of contents for this document">&nbsp;Table of contents</a></li>
	<li class="page_item"><a href="http://fenicsproject.org/about/" title="Find out more about the FEniCS project">About</a></li>
	<li class="page_item"><a href="http://fenicsproject.org/download/" title="Obtain the FEniCS project">Download</a></li>
	<li class="page_item"><a href="http://fenicsproject.org/documentation/" title="Learn how to use the FEniCS project">Documentation</a></li>
	<li class="page_item"><a href="http://fenicsproject.org/applications/" title="Learn how others are using the FEniCS project">Applications</a></li>
	<li class="page_item"><a href="http://fenicsproject.org/contributing/" title="Learn how to contribute to the FEniCS project">Contributing</a></li>
	<li class="page_item"><a href="http://fenicsproject.org/citing/" title="Learn how to cite the FEniCS project">Citing</a></li>
	<li class="page_item"><a href="http://fenicsproject.org/support/" title="Where to go for more help">Support</a></li>
      </ul>
    </div><!-- .menu -->
  </div><!-- #access -->
</div><!-- #wrapper -->


    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="fundamentals">
<span id="tut-fundamentals"></span><h1>Fundamentals<a class="headerlink" href="#fundamentals" title="Permalink to this headline">¶</a></h1>
<p>FEniCS is a user-friendly tool for solving partial differential
equations (PDEs). The goal of this tutorial is to get you started with
FEniCS through a series of simple examples that demonstrate</p>
<blockquote>
<div><ul class="simple">
<li>how to define the PDE problem in terms of a variational problem,</li>
<li>how to define simple domains,</li>
<li>how to deal with Dirichlet, Neumann, and Robin conditions,</li>
<li>how to deal with variable coefficients,</li>
<li>how to deal with domains built of several materials (subdomains),</li>
<li>how to compute derived quantities like the flux vector field or
a functional of the solution,</li>
<li>how to quickly visualize the mesh, the solution, the flux, etc.,</li>
<li>how to solve nonlinear PDEs in various ways,</li>
<li>how to deal with time-dependent PDEs,</li>
<li>how to set parameters governing solution methods for linear systems,</li>
<li>how to create domains of more complex shape.</li>
</ul>
</div></blockquote>
<p>The mathematics of the illustrations is kept simple to better focus
on FEniCS functionality and syntax. This means that we mostly use
the Poisson equation and the time-dependent diffusion equation
as model problems, often with input data adjusted such that we get
a very simple solution that can be exactly reproduced by any standard
finite element method over a uniform, structured mesh. This
latter property greatly simplifies the verification of the implementations.
Occasionally we insert a physically more relevant example
to remind the reader that changing the PDE and boundary
conditions to something more real might often be a trivial task.</p>
<p>FEniCS may seem to require a thorough understanding of the abstract
mathematical version of the finite element method as well as
familiarity with the Python programming language.  Nevertheless, it
turns out that many are able to pick up the fundamentals of finite
elements <em>and</em> Python programming as they go along with this
tutorial. Simply keep on reading and try out the examples. You will be
amazed of how easy it is to solve PDEs with FEniCS!</p>
<p>Reading this tutorial obviously requires access to a machine where the
FEniCS software is installed. The section <a class="reference internal" href="._ftut007.html#tut-app-install"><span class="std std-ref">Installing FEniCS</span></a> explains
briefly how to install the necessary tools.</p>
<p>All the examples discussed in the following are available as
executable Python source code files in a <a class="reference external" href="https://github.com/hplgit/fenics-tutorial/blob/master/src">directory tree</a>.
File paths reflect the nature of the PDE problem being solved. For
example, <code class="docutils literal"><span class="pre">stationary/poisson/d2_p2D.py</span></code> has a descriptive directory
path and a very brief Unix-style filename. The latter indicates a
second Dirichlet problem example (<code class="docutils literal"><span class="pre">d2</span></code>), with a brief postfix <code class="docutils literal"><span class="pre">p2D</span></code>
which here is meant to identify a 2D Poisson problem and help to
provide a unique filename among all the programs.  Quite similarly,
<code class="docutils literal"><span class="pre">transient/diffusion/sin_daD.py</span></code> is the file associated with a
transient diffusion PDE, with <code class="docutils literal"><span class="pre">sin</span></code> as an identifier for a sinusoidal
boundary condition in time and <code class="docutils literal"><span class="pre">daD</span></code> as an identifier for a diffusion
problem (<code class="docutils literal"><span class="pre">d</span></code>) where the code works in &#8220;anyD&#8221; (<code class="docutils literal"><span class="pre">aD</span></code>), i.e., 1D,
2D, or 3D. We will occasionally only make references to the basename
of a previously introduced filename, say <code class="docutils literal"><span class="pre">d2_p2D.py</span></code>, instead of the
much longer complete name <code class="docutils literal"><span class="pre">stationary/poisson/d2_p2D.py</span></code>.</p>
<p><strong>The FEniCS version.</strong>
This document is up-to-date with FEniCS version 1.6. To see which version
you have, run the following command in a Unix/Linux terminal window if
you run Python version 2.7:</p>
<div class="highlight-text"><div class="highlight"><pre>Terminal&gt; python -c &#39;import dolfin; print dolfin.__version__&#39;
1.6.0
</pre></div>
</div>
<p>In Python version 3.x you must write</p>
<div class="highlight-text"><div class="highlight"><pre>Terminal&gt; python -c &#39;import dolfin; print(dolfin.__version__)&#39;
1.6.0
</pre></div>
</div>
<p><strong>The Python version.</strong>
Python comes in two versions, 2 and 3, and these are not compatible.
FEniCS has a code base that runs under both versions.
All the programs in this tutorial are also developed such that they
can be run under both Python 2 and 3. Programs that need to print must
then start with</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">print_function</span>
</pre></div>
</div>
<p>to  enable the <code class="docutils literal"><span class="pre">print</span></code> function from Python 3 in Python 2. All
use of <code class="docutils literal"><span class="pre">print</span></code> in the programs consists of function calls, like
<code class="docutils literal"><span class="pre">print('a:',</span> <span class="pre">a)</span></code>. Almost all other constructions are of a form that looks the
same in Python 2 and 3.</p>
<div class="section" id="the-poisson-equation">
<span id="tut-poisson1-bvp"></span><h2>The Poisson equation<a class="headerlink" href="#the-poisson-equation" title="Permalink to this headline">¶</a></h2>
<p id="index-0">Let us start with a &#8220;Hello, World!&#8221; program in the world of PDEs - it
must be a program that solves the Laplace or Poisson equation.
Our first example regards the following Poisson problem,</p>
<div class="math" id="eq-tut-poisson1">
\[\tag{1}
- \nabla^2 u(\boldsymbol{x}) = f(\boldsymbol{x}),\quad \boldsymbol{x}\mbox{ in } \Omega,\]</div>
<div class="math" id="eq-tut-poisson1-bc">
\[\tag{2}
u(\boldsymbol{x}) = u_0(\boldsymbol{x}),\quad \boldsymbol{x}\mbox{ on } \partial \Omega{\thinspace .}\]</div>
<p>Here, <span class="math">\(u(\boldsymbol{x})\)</span> is the unknown function, <span class="math">\(f(\boldsymbol{x})\)</span> is a
prescribed function, <span class="math">\(\nabla^2\)</span> is the Laplace operator (also
often written as <span class="math">\(\Delta\)</span>), <span class="math">\(\Omega\)</span> is the spatial domain, and
<span class="math">\(\partial\Omega\)</span> is the boundary of <span class="math">\(\Omega\)</span>. A stationary PDE like
this, together with a complete set of boundary conditions, constitute
a <em>boundary-value problem</em>, which must be precisely stated before
it makes sense to start solving it with FEniCS.</p>
<p>In two space dimensions with coordinates <span class="math">\(x\)</span> and <span class="math">\(y\)</span>, we can write out
the Poisson equation as</p>
<div class="math" id="eq-auto1">
\[\tag{3}
- {\partial^2 u\over\partial x^2} -
    {\partial^2 u\over\partial y^2} = f(x,y){\thinspace .}\]</div>
<p>The unknown <span class="math">\(u\)</span> is now a function of two variables, <span class="math">\(u(x,y)\)</span>, defined
over a two-dimensional domain <span class="math">\(\Omega\)</span>.</p>
<p>The Poisson equation arises in numerous physical contexts, including
heat conduction, electrostatics, diffusion of substances, twisting of
elastic rods, inviscid fluid flow, and water waves. Moreover, the
equation appears in numerical splitting strategies of more complicated
systems of PDEs, in particular the Navier-Stokes equations.</p>
<p>Solving a physical problem with FEniCS consists
of the following steps:</p>
<blockquote>
<div><ol class="arabic simple">
<li>Identify the PDE and its boundary conditions.</li>
<li>Reformulate the PDE problem as a variational problem.</li>
<li>Make a Python program where the formulas in the variational
problem are coded, along with definitions of input data such as
<span class="math">\(f\)</span>, <span class="math">\(u_0\)</span>, and a mesh for the spatial domain <span class="math">\(\Omega\)</span>.</li>
<li>Add statements in the program for solving the variational
problem, computing derived quantities such as <span class="math">\(\nabla u\)</span>, and
visualizing the results.</li>
</ol>
</div></blockquote>
<p>We shall now go through steps 2-4 in detail.  The key feature of
FEniCS is that steps 3 and 4 result in fairly short code, while most
other software frameworks for PDEs require much more code and more
technically difficult programming.</p>
</div>
<div class="section" id="variational-formulation">
<span id="tut-poisson1-varform"></span><h2>Variational formulation<a class="headerlink" href="#variational-formulation" title="Permalink to this headline">¶</a></h2>
<p id="index-1">FEniCS makes it easy to solve PDEs if finite elements are used for
discretization in space and the problem is expressed as a
<em>variational problem</em>. Readers who are not familiar with
variational problems will get a brief introduction to the topic in
this tutorial, but getting and reading
a proper book on the finite element method in addition is encouraged.
The section <a class="reference internal" href="._ftut007.html#tut-appendix-books"><span class="std std-ref">Books on the finite element method</span></a> contains a list of some suitable
books.</p>
<span class="target" id="index-2"></span><p id="index-3">The core of the recipe for turning a PDE into a variational problem
is to multiply the PDE by a function <span class="math">\(v\)</span>, integrate the resulting
equation over <span class="math">\(\Omega\)</span>, and perform integration by parts of terms with
second-order derivatives. The function <span class="math">\(v\)</span> which multiplies the PDE
is in the mathematical finite element literature
called a <em>test function</em>. The unknown function <span class="math">\(u\)</span> to be approximated
is referred to
as a <em>trial function</em>. The terms test and trial function are used
in FEniCS programs too.
Suitable
function spaces must be specified for the test and trial functions.
For standard PDEs arising in physics and mechanics such spaces are
well known.</p>
<p>In the present case, we first multiply the Poisson equation
by the test function <span class="math">\(v\)</span> and integrate,</p>
<div class="math" id="eq-tut-poisson1-multbyv">
\[\tag{4}
-\int_\Omega (\nabla^2 u)v {\, \mathrm{d}x} = \int_\Omega fv {\, \mathrm{d}x}{\thinspace .}\]</div>
<p>Then we apply integration by parts to the integrand with
second-order derivatives,</p>
<div class="math" id="eq-tut-poisson1-eqbyparts">
\[\tag{5}
-\int_\Omega (\nabla^2 u)v {\, \mathrm{d}x}
    = \int_\Omega\nabla u\cdot\nabla v {\, \mathrm{d}x} - \int_{\partial\Omega}{\partial u\over
    \partial n}v {\, \mathrm{d}s} ,\]</div>
<p>where <span class="math">\(\frac{\partial u}{\partial n}\)</span> is the derivative of <span class="math">\(u\)</span> in
the outward normal direction at the boundary.
The test function <span class="math">\(v\)</span> is required to vanish on the parts of the
boundary where <span class="math">\(u\)</span> is known, which in the present problem implies that
<span class="math">\(v=0\)</span> on the whole boundary <span class="math">\(\partial\Omega\)</span>.
The second term on
the right-hand side of <a class="reference internal" href="#eq-tut-poisson1-eqbyparts"><span class="std std-ref">(5)</span></a> therefore vanishes.
From <a class="reference internal" href="#eq-tut-poisson1-multbyv"><span class="std std-ref">(4)</span></a> and <a class="reference internal" href="#eq-tut-poisson1-eqbyparts"><span class="std std-ref">(5)</span></a>
it follows that</p>
<div class="math" id="eq-tut-poisson1-weak1">
\[\tag{6}
\int_\Omega\nabla u\cdot\nabla v {\, \mathrm{d}x} = \int_\Omega fv {\, \mathrm{d}x}{\thinspace .}\]</div>
<p>This equation is supposed to hold
for all <span class="math">\(v\)</span> in some function space <span class="math">\(\hat V\)</span>. The trial function <span class="math">\(u\)</span>
lies in some (possibly different) function space <span class="math">\(V\)</span>.
We refer to <a class="reference internal" href="#eq-tut-poisson1-weak1"><span class="std std-ref">(6)</span></a> as the <em>weak form</em> or
<em>variational form</em> of
the original boundary-value problem
<a class="reference internal" href="#eq-tut-poisson1"><span class="std std-ref">(1)</span></a>-<a class="reference internal" href="#eq-tut-poisson1-bc"><span class="std std-ref">(2)</span></a>.</p>
<p>The proper statement of
our variational problem now goes as follows:
Find <span class="math">\(u \in V\)</span> such that</p>
<div class="math" id="eq-tut-poisson1-var">
\[\tag{7}
\int_{\Omega} \nabla u \cdot \nabla v {\, \mathrm{d}x} =
      \int_{\Omega} fv {\, \mathrm{d}x}
      \quad \forall v \in \hat{V}.\]</div>
<p>The test and trial spaces <span class="math">\(\hat{V}\)</span> and <span class="math">\(V\)</span> are in the present
problem defined as</p>
<div class="math">
\[\begin{split}\hat{V} &amp;= \{v \in H^1(\Omega) : v = 0 \mbox{ on } \partial\Omega\}, \\
 V      &amp;= \{v \in H^1(\Omega) : v = u_0 \mbox{ on } \partial\Omega\}{\thinspace .}\end{split}\]</div>
<p>In short,
<span class="math">\(H^1(\Omega)\)</span> is the mathematically well-known Sobolev space containing
functions <span class="math">\(v\)</span> such that <span class="math">\(v^2\)</span> and <span class="math">\(||\nabla v||^2\)</span> have finite integrals over
<span class="math">\(\Omega\)</span>. The solution of the underlying
PDE
must lie in a function space where also the derivatives are continuous,
but the Sobolev space <span class="math">\(H^1(\Omega)\)</span> allows functions with discontinuous
derivatives.
This weaker continuity requirement of <span class="math">\(u\)</span> in the variational
statement <a class="reference internal" href="#eq-tut-poisson1-var"><span class="std std-ref">(7)</span></a>,
caused by the integration by parts, has
great practical consequences when it comes to constructing
finite elements.</p>
<p>To solve the Poisson equation numerically, we need to transform the
continuous variational problem
<a class="reference internal" href="#eq-tut-poisson1-var"><span class="std std-ref">(7)</span></a>
to a discrete variational
problem. This is done by introducing <em>finite-dimensional</em> test and
trial spaces, often denoted as
<span class="math">\(\hat{V}_h\subset\hat{V}\)</span> and <span class="math">\(V_h\subset{V}\)</span>. The
discrete variational problem reads:
Find <span class="math">\(u_h \in V_h \subset V\)</span> such that</p>
<div class="math" id="eq-tut-poisson1-vard">
\[\tag{8}
\int_{\Omega} \nabla u_h \cdot \nabla v {\, \mathrm{d}x} =
      \int_{\Omega} fv {\, \mathrm{d}x}
      \quad \forall v \in \hat{V}_h \subset \hat{V}{\thinspace .}\]</div>
<p>The choice of <span class="math">\(\hat{V}_h\)</span> and <span class="math">\(V_h\)</span> follows directly from the
kind of finite elements we want to apply in our problem. For example,
choosing the well-known linear triangular element with three nodes
implies that
<span class="math">\(\hat V_h\)</span> and <span class="math">\(V_h\)</span> are the spaces of all piecewise linear functions
over a mesh of triangles,
where the functions in <span class="math">\(\hat V_h\)</span>
are zero on the boundary
and those in <span class="math">\(V_h\)</span> equal <span class="math">\(u_0\)</span> on the boundary.</p>
<p>The mathematics literature on variational problems writes <span class="math">\(u_h\)</span> for
the solution of the discrete problem and <span class="math">\(u\)</span> for the solution of the
continuous problem. To obtain (almost) a one-to-one relationship
between the mathematical formulation of a problem and the
corresponding FEniCS program, we shall use <span class="math">\(u\)</span> for the solution of
the discrete problem and <span class="math">\(u_{e}\)</span> for the exact solution of the
continuous problem, <em>if</em> we need to explicitly distinguish
between the two.  In most cases, we will introduce the PDE problem with
<span class="math">\(u\)</span> as unknown, derive a variational equation <span class="math">\(a(u,v)=L(v)\)</span> with <span class="math">\(u\in
V\)</span> and <span class="math">\(v\in \hat V\)</span>, and then simply discretize the problem by saying
that we choose finite-dimensional spaces for <span class="math">\(V\)</span> and <span class="math">\(\hat V\)</span>. This
restriction of <span class="math">\(V\)</span> implies that <span class="math">\(u\)</span> becomes a discrete finite element
function.  In practice, this means that we turn our PDE problem into a
continuous variational problem, create a mesh and specify an element
type, and then let <span class="math">\(V\)</span> correspond to this mesh and element choice.
Depending upon whether <span class="math">\(V\)</span> is infinite- or finite-dimensional, <span class="math">\(u\)</span>
will be the exact or approximate solution.</p>
<p>It turns out to be convenient to
introduce the following unified notation for linear weak forms:</p>
<div class="math" id="eq-auto2">
\[\tag{9}
a(u, v) = L(v){\thinspace .}\]</div>
<p>In the present problem we have that</p>
<div class="math" id="eq-tut-poisson1-vard-a">
\[\tag{10}
a(u, v) = \int_{\Omega} \nabla u \cdot \nabla v {\, \mathrm{d}x},\]</div>
<div class="math" id="eq-tut-poisson1-vard-l">
\[\tag{11}
L(v) = \int_{\Omega} fv {\, \mathrm{d}x}{\thinspace .}\]</div>
<p>From the mathematics literature,
<span class="math">\(a(u,v)\)</span> is known as a <em>bilinear form</em> and <span class="math">\(L(v)\)</span> as a
<em>linear form</em>.
We shall in every linear problem we solve identify the terms with the
unknown <span class="math">\(u\)</span> and collect them in <span class="math">\(a(u,v)\)</span>, and similarly collect
all terms with only known functions in <span class="math">\(L(v)\)</span>. The formulas for <span class="math">\(a\)</span> and
<span class="math">\(L\)</span> are then coded directly in the program.</p>
<p>To summarize, before making a FEniCS program for solving a PDE,
we must first perform two steps:</p>
<blockquote>
<div><ul class="simple">
<li>Turn the PDE problem into a discrete
variational problem: find <span class="math">\(u\in V\)</span>
such that <span class="math">\(a(u,v) = L(v)\quad\forall v\in \hat{V}\)</span>.</li>
<li>Specify the choice of spaces (<span class="math">\(V\)</span> and <span class="math">\(\hat V\)</span>), which means
specifying the mesh and type of finite elements.</li>
</ul>
</div></blockquote>
</div>
<div class="section" id="implementation-1">
<span id="tut-poisson1-impl"></span><h2>Implementation<a class="headerlink" href="#implementation-1" title="Permalink to this headline">¶</a></h2>
<p id="index-4">The test problem so far has a general domain <span class="math">\(\Omega\)</span> and general functions
<span class="math">\(u_0\)</span> and <span class="math">\(f\)</span>. For our first implementation we must decide on specific
choices of <span class="math">\(\Omega\)</span>, <span class="math">\(u_0\)</span>, and <span class="math">\(f\)</span>.
It will be wise to construct a specific problem where we can easily
check that the computed solution is correct. Let us start with
specifying an exact solution</p>
<div class="math" id="eq-tut-poisson1-impl-uex">
\[\tag{12}
\
    u_{\rm e}(x, y) = 1 +x^2 + 2y^2\]</div>
<p>on some 2D domain.  By inserting <a class="reference internal" href="#eq-tut-poisson1-impl-uex"><span class="std std-ref">(12)</span></a> in
our Poisson problem, we find that <span class="math">\(u_{\rm e}(x,y)\)</span> is a solution if</p>
<div class="math">
\[f(x,y) = -6,\quad u_0(x,y)=u_{\rm e}(x,y)=1 + x^2 + 2y^2,\]</div>
<p>regardless of the shape of the domain. We choose here, for simplicity,
the domain to be the unit square,</p>
<div class="math">
\[\Omega = [0,1]\times [0,1] .\]</div>
<p>The reason for specifying the solution <a class="reference internal" href="#eq-tut-poisson1-impl-uex"><span class="std std-ref">(12)</span></a>
is that the finite element method, with a rectangular domain uniformly
partitioned into linear triangular elements, will exactly reproduce a
second-order polynomial at the vertices of the cells, regardless of
the size of the elements. This property allows us to verify the
implementation by comparing the computed solution, called <span class="math">\(u\)</span> in this
document (except when setting up the PDE problem), with the exact
solution, denoted by <span class="math">\(u_{\rm e}\)</span>: <span class="math">\(u\)</span> should equal
<span class="math">\(u_{\rm e}\)</span> to machine precision <em>at the nodes</em>.
Test problems with this property will be frequently constructed
throughout this tutorial.</p>
<div class="section" id="the-code">
<h3>The code<a class="headerlink" href="#the-code" title="Permalink to this headline">¶</a></h3>
<p>A FEniCS program for solving the Poisson equation in 2D
with the given choices
of <span class="math">\(u_0\)</span>, <span class="math">\(f\)</span>, and <span class="math">\(\Omega\)</span> may look as follows:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">dolfin</span> <span class="kn">import</span> <span class="o">*</span>

<span class="c"># Create mesh and define function space</span>
<span class="n">mesh</span> <span class="o">=</span> <span class="n">UnitSquareMesh</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="n">V</span> <span class="o">=</span> <span class="n">FunctionSpace</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="s">&#39;Lagrange&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

<span class="c"># Define boundary conditions</span>
<span class="n">u0</span> <span class="o">=</span> <span class="n">Expression</span><span class="p">(</span><span class="s">&#39;1 + x[0]*x[0] + 2*x[1]*x[1]&#39;</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">u0_boundary</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">on_boundary</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">on_boundary</span>

<span class="n">bc</span> <span class="o">=</span> <span class="n">DirichletBC</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="n">u0</span><span class="p">,</span> <span class="n">u0_boundary</span><span class="p">)</span>

<span class="c"># Define variational problem</span>
<span class="n">u</span> <span class="o">=</span> <span class="n">TrialFunction</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
<span class="n">v</span> <span class="o">=</span> <span class="n">TestFunction</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
<span class="n">f</span> <span class="o">=</span> <span class="n">Constant</span><span class="p">(</span><span class="o">-</span><span class="mf">6.0</span><span class="p">)</span>
<span class="n">a</span> <span class="o">=</span> <span class="n">inner</span><span class="p">(</span><span class="n">nabla_grad</span><span class="p">(</span><span class="n">u</span><span class="p">),</span> <span class="n">nabla_grad</span><span class="p">(</span><span class="n">v</span><span class="p">))</span><span class="o">*</span><span class="n">dx</span>
<span class="n">L</span> <span class="o">=</span> <span class="n">f</span><span class="o">*</span><span class="n">v</span><span class="o">*</span><span class="n">dx</span>

<span class="c"># Compute solution</span>
<span class="n">u</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
<span class="n">solve</span><span class="p">(</span><span class="n">a</span> <span class="o">==</span> <span class="n">L</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">bc</span><span class="p">)</span>

<span class="c"># Plot solution and mesh</span>
<span class="n">plot</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>

<span class="c"># Dump solution to file in VTK format</span>
<span class="nb">file</span> <span class="o">=</span> <span class="n">File</span><span class="p">(</span><span class="s">&quot;poisson.pvd&quot;</span><span class="p">)</span>
<span class="nb">file</span> <span class="o">&lt;&lt;</span> <span class="n">u</span>

<span class="c"># Hold plot</span>
<span class="n">interactive</span><span class="p">()</span>
</pre></div>
</div>
<p>The complete code can be found in the file <a class="reference external" href="https://github.com/hplgit/fenics-tutorial/blob/master/src/stationary/poisson/d1_p2D.py">d1_p2D.py</a> in the
directory <a class="reference external" href="https://github.com/hplgit/fenics-tutorial/blob/master/src/stationary/poisson">src/stationary/poisson</a>.</p>
</div>
<div class="section" id="running-the-program">
<h3>Running the program<a class="headerlink" href="#running-the-program" title="Permalink to this headline">¶</a></h3>
<p>To run the program <code class="docutils literal"><span class="pre">d1_p2D.py</span></code>, open a terminal window, move to
the directory containing the program and write</p>
<div class="highlight-text"><div class="highlight"><pre>Terminal&gt; python d1_p2D.py
</pre></div>
</div>
<p>A plot window pops up showing how the solution <span class="math">\(u\)</span> looks like as a surface.
With the left mouse button you can tilt the figure. Click <code class="docutils literal"><span class="pre">m</span></code> to bring
up the underlying mesh. Click <code class="docutils literal"><span class="pre">p</span></code> to save to a PNG file <code class="docutils literal"><span class="pre">dolfin_plot_0.png</span></code>
and <code class="docutils literal"><span class="pre">P</span></code> to save to a PDF file <code class="docutils literal"><span class="pre">dolfin_plot_1.pdf</span></code>. To kill the
plot window and terminate the application, click <code class="docutils literal"><span class="pre">Ctrl+q</span></code> (hold down
the <code class="docutils literal"><span class="pre">Ctrl</span></code> key and press <code class="docutils literal"><span class="pre">q</span></code>).
Figure <a class="reference internal" href="#tut-poisson-2d-fig-ex1-u"><span class="std std-ref">Plot of the solution in the first FEniCS example</span></a> displays the surface and the mesh below.
Since <span class="math">\(u\)</span> is a simple quadratic function,
constructed for testing our solver, the
surface looks quite boring.</p>
<div class="figure" id="id5">
<span id="tut-poisson-2d-fig-ex1-u"></span><a class="reference internal image-reference" href="_images/ex1_u.png"><img alt="_images/ex1_u.png" src="_images/ex1_u.png" style="width: 600px;" /></a>
<p class="caption"><span class="caption-text"><em>Plot of the solution in the first FEniCS example</em></span></p>
</div>
</div>
<div class="section" id="dissection-of-the-program">
<h3>Dissection of the program<a class="headerlink" href="#dissection-of-the-program" title="Permalink to this headline">¶</a></h3>
<p>We shall now dissect this FEniCS program in detail. The program
is written in the Python programming language.
You may either take a quick look at the
<a class="reference external" href="http://docs.python.org/tutorial/">official Python tutorial</a>
to pick up the basics of Python if you are unfamiliar with the language,
or you may learn enough Python as you go along with the examples in the
present tutorial. The latter strategy has proven to work for many newcomers
to FEniCS. (The requirement of using Python and an abstract
mathematical formulation of the finite element problem may seem
difficult for those who are unfamiliar with these topics.
However, the amount of mathematics and Python that is really demanded
to get you productive with FEniCS is quite limited.
And Python is an easy-to-learn language that you certainly will love
and use far beyond FEniCS programming.)
the section <a class="reference internal" href="._ftut007.html#tut-appendix-pybooks"><span class="std std-ref">Books on Python</span></a> lists some relevant Python books.</p>
<p>The listed FEniCS program defines a finite element mesh, the discrete
function spaces <span class="math">\(V\)</span> and <span class="math">\(\hat{V}\)</span> corresponding to this mesh and
the element type, boundary conditions
for <span class="math">\(u\)</span> (the function <span class="math">\(u_0\)</span>), <span class="math">\(a(u,v)\)</span>, and <span class="math">\(L(v)\)</span>.
Thereafter, the unknown
trial function <span class="math">\(u\)</span> is computed. Then we can investigate <span class="math">\(u\)</span> visually or
analyze the computed values.</p>
<p>The first line in the program,</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">dolfin</span> <span class="kn">import</span> <span class="o">*</span>
</pre></div>
</div>
<p>imports the key classes <code class="docutils literal"><span class="pre">UnitSquareMesh</span></code>,
<code class="docutils literal"><span class="pre">FunctionSpace</span></code>, <code class="docutils literal"><span class="pre">Function</span></code>, and so forth, from the DOLFIN library.
All FEniCS programs for solving PDEs by the finite element method
normally start with this line. DOLFIN is a software library with efficient
and convenient C++ classes for finite element computing, and
<code class="docutils literal"><span class="pre">dolfin</span></code> is a Python package providing access to this
C++ library from Python programs.
You can think of FEniCS as an umbrella, or project name, for a set of
computational components, where DOLFIN is one important component for
writing finite element programs. The <code class="docutils literal"><span class="pre">from</span> <span class="pre">dolfin</span> <span class="pre">import</span> <span class="pre">*</span></code> statement
imports other components too, but newcomers to FEniCS
programming do not need to care about this.</p>
<span class="target" id="index-5"></span><p id="index-6">The statement</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">mesh</span> <span class="o">=</span> <span class="n">UnitSquareMesh</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
</pre></div>
</div>
<p>defines a uniform finite element mesh over the unit square
<span class="math">\([0,1]\times [0,1]\)</span>. The mesh consists of <em>cells</em>,
which are triangles with
straight sides. The parameters 6 and 4 tell that the square is
first divided into <span class="math">\(6\times 4\)</span> rectangles, and then each rectangle
is divided into two triangles. The total number of triangles
then becomes 48. The total number of vertices in this mesh is
<span class="math">\(7\cdot 5=35\)</span>.
DOLFIN offers some classes for creating meshes over
very simple geometries. For domains of more complicated shape one needs
to use a separate <em>preprocessor</em> program to create the mesh.
The FEniCS program will then read the mesh from file.</p>
<p id="index-7">Having a mesh, we can define a discrete function space <code class="docutils literal"><span class="pre">V</span></code> over this mesh:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">V</span> <span class="o">=</span> <span class="n">FunctionSpace</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="s">&#39;Lagrange&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p>The second argument reflects the type of element, while the third
argument is the degree of the basis functions on the element.</p>
<span class="target" id="index-8"></span><span class="target" id="index-9"></span><p id="index-10">The type of element is here &#8220;Lagrange&#8221;, implying the
standard Lagrange family of elements.
(Some FEniCS programs use <code class="docutils literal"><span class="pre">'CG'</span></code>, for Continuous Galerkin,
as a synonym for <code class="docutils literal"><span class="pre">'Lagrange'</span></code>.)
With degree 1, we simply get the standard linear Lagrange element,
which is a triangle
with nodes at the three vertices.
Some finite element practitioners refer to this element as the
&#8220;linear triangle&#8221;.
The computed <span class="math">\(u\)</span> will be continuous and linearly varying in <span class="math">\(x\)</span> and <span class="math">\(y\)</span> over
each cell in the mesh.
Higher-degree polynomial approximations over each cell are
trivially obtained by increasing the third parameter in
<code class="docutils literal"><span class="pre">FunctionSpace</span></code>. Changing the second parameter to <code class="docutils literal"><span class="pre">'DG'</span></code> creates a
function space for discontinuous Galerkin methods.</p>
<span class="target" id="index-11"></span><span class="target" id="index-12"></span><span class="target" id="index-13"></span><p id="index-14">In mathematics, we distinguish between the trial and test
spaces <span class="math">\(V\)</span> and <span class="math">\(\hat{V}\)</span>. The only difference in the present problem
is the boundary conditions. In FEniCS we do not specify the boundary
conditions as part of the function space, so it is sufficient to work
with one common space <code class="docutils literal"><span class="pre">V</span></code> for the and trial and test functions in the
program:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">u</span> <span class="o">=</span> <span class="n">TrialFunction</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
<span class="n">v</span> <span class="o">=</span> <span class="n">TestFunction</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
</pre></div>
</div>
<p id="index-15">The next step is to specify the boundary condition: <span class="math">\(u=u_0\)</span> on
<span class="math">\(\partial\Omega\)</span>. This is done by</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">bc</span> <span class="o">=</span> <span class="n">DirichletBC</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="n">u0</span><span class="p">,</span> <span class="n">u0_boundary</span><span class="p">)</span>
</pre></div>
</div>
<p>where <code class="docutils literal"><span class="pre">u0</span></code> is an instance holding the <span class="math">\(u_0\)</span> values,
and <code class="docutils literal"><span class="pre">u0_boundary</span></code> is a function (or object) describing whether a point lies
on the boundary where <span class="math">\(u\)</span> is specified.</p>
<p>Boundary conditions
of the type <span class="math">\(u=u_0\)</span> are known as <em>Dirichlet conditions</em>, and also
as <em>essential boundary conditions</em> in a finite element context.
Naturally, the name of the DOLFIN class holding the information about
Dirichlet boundary conditions is <code class="docutils literal"><span class="pre">DirichletBC</span></code>.</p>
<p id="index-16">The <code class="docutils literal"><span class="pre">u0</span></code> variable refers to an <code class="docutils literal"><span class="pre">Expression</span></code> object, which
is used to represent a mathematical function. The typical construction is</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">u0</span> <span class="o">=</span> <span class="n">Expression</span><span class="p">(</span><span class="n">formula</span><span class="p">)</span>
</pre></div>
</div>
<p>where <code class="docutils literal"><span class="pre">formula</span></code> is a string containing the mathematical expression.
This formula is
written with C++ syntax (the expression is
automatically turned into an efficient, compiled
C++ function, see the section <a class="reference internal" href="._ftut007.html#tut-app-cpp-functions"><span class="std std-ref">User-defined functions</span></a> for
details on the syntax). The independent variables in the function
expression are supposed to be available
as a point vector <code class="docutils literal"><span class="pre">x</span></code>, where the first element <code class="docutils literal"><span class="pre">x[0]</span></code>
corresponds to the <span class="math">\(x\)</span> coordinate, the second element <code class="docutils literal"><span class="pre">x[1]</span></code>
to the <span class="math">\(y\)</span> coordinate, and (in a three-dimensional problem)
<code class="docutils literal"><span class="pre">x[2]</span></code> to the <span class="math">\(z\)</span> coordinate. With our choice of
<span class="math">\(u_0(x,y)=1 + x^2 + 2y^2\)</span>, the formula string must be written
as <code class="docutils literal"><span class="pre">1</span> <span class="pre">+</span> <span class="pre">x[0]*x[0]</span> <span class="pre">+</span> <span class="pre">2*x[1]*x[1]</span></code>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">u0</span> <span class="o">=</span> <span class="n">Expression</span><span class="p">(</span><span class="s">&#39;1 + x[0]*x[0] + 2*x[1]*x[1]&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>The information about where to apply the <code class="docutils literal"><span class="pre">u0</span></code> function as
boundary condition is coded in a function <code class="docutils literal"><span class="pre">u0_boundary</span></code>:</p>
<div class="highlight-python" id="index-17"><div class="highlight"><pre><span class="k">def</span> <span class="nf">u0_boundary</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">on_boundary</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">on_boundary</span>
</pre></div>
</div>
<p>A function like <code class="docutils literal"><span class="pre">u0_boundary</span></code> for marking the boundary must
return
a boolean value: <code class="docutils literal"><span class="pre">True</span></code> if the given point
<code class="docutils literal"><span class="pre">x</span></code> lies on the Dirichlet boundary and
<code class="docutils literal"><span class="pre">False</span></code> otherwise.
The argument <code class="docutils literal"><span class="pre">on_boundary</span></code> is <code class="docutils literal"><span class="pre">True</span></code> if <code class="docutils literal"><span class="pre">x</span></code> is on
the physical boundary of the mesh, so in the present case, where
we are supposed to return <code class="docutils literal"><span class="pre">True</span></code> for all points on
the boundary, we can just return the supplied value of
<code class="docutils literal"><span class="pre">on_boundary</span></code>.
The <code class="docutils literal"><span class="pre">u0_boundary</span></code> function will be called
for every discrete point in the mesh, which allows us to have boundaries
where <span class="math">\(u\)</span> are known also inside the domain, if desired.</p>
<p>One can also omit the <code class="docutils literal"><span class="pre">on_boundary</span></code> argument,
but in that case we need to test on the value of the coordinates
in <code class="docutils literal"><span class="pre">x</span></code>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">u0_boundary</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span>
</pre></div>
</div>
<p>As for the formula in <code class="docutils literal"><span class="pre">Expression</span></code> objects, <code class="docutils literal"><span class="pre">x</span></code> in the
<code class="docutils literal"><span class="pre">u0_boundary</span></code> function represents a point in space with
coordinates <code class="docutils literal"><span class="pre">x[0]</span></code>, <code class="docutils literal"><span class="pre">x[1]</span></code>, etc. Comparing floating-point
values using an exact match test with <code class="docutils literal"><span class="pre">==</span></code>
is not good programming practice, because small round-off errors in
the computations of the <code class="docutils literal"><span class="pre">x</span></code> values could make a test
<code class="docutils literal"><span class="pre">x[0]</span> <span class="pre">==</span> <span class="pre">1</span></code> become false even though <code class="docutils literal"><span class="pre">x</span></code> lies on the boundary.
A better test is to check for equality with a tolerance:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">u0_boundary</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="n">tol</span> <span class="o">=</span> <span class="mf">1E-15</span>
    <span class="k">return</span> <span class="nb">abs</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">&lt;</span> <span class="n">tol</span> <span class="ow">or</span> \
           <span class="nb">abs</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">&lt;</span> <span class="n">tol</span> <span class="ow">or</span> \
           <span class="nb">abs</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">tol</span> <span class="ow">or</span> \
           <span class="nb">abs</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">tol</span>
</pre></div>
</div>
<p id="index-18">Before defining <span class="math">\(a(u,v)\)</span> and <span class="math">\(L(v)\)</span> we have to specify the <span class="math">\(f\)</span> function:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">f</span> <span class="o">=</span> <span class="n">Expression</span><span class="p">(</span><span class="s">&#39;-6&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>When <span class="math">\(f\)</span> is constant over the domain, <code class="docutils literal"><span class="pre">f</span></code> can be
more efficiently represented as a <code class="docutils literal"><span class="pre">Constant</span></code> object:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">f</span> <span class="o">=</span> <span class="n">Constant</span><span class="p">(</span><span class="o">-</span><span class="mf">6.0</span><span class="p">)</span>
</pre></div>
</div>
<p>Now we have all the objects we need in order to specify this problem&#8217;s
<span class="math">\(a(u,v)\)</span> and <span class="math">\(L(v)\)</span>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">a</span> <span class="o">=</span> <span class="n">inner</span><span class="p">(</span><span class="n">nabla_grad</span><span class="p">(</span><span class="n">u</span><span class="p">),</span> <span class="n">nabla_grad</span><span class="p">(</span><span class="n">v</span><span class="p">))</span><span class="o">*</span><span class="n">dx</span>
<span class="n">L</span> <span class="o">=</span> <span class="n">f</span><span class="o">*</span><span class="n">v</span><span class="o">*</span><span class="n">dx</span>
</pre></div>
</div>
<p>In essence, these two lines specify the PDE to be solved.
Note the very close correspondence between the Python syntax
and the mathematical formulas <span class="math">\(\nabla u\cdot\nabla v {\, \mathrm{d}x}\)</span> and
<span class="math">\(fv {\, \mathrm{d}x}\)</span>.
This is a key strength of FEniCS: the formulas in the variational
formulation translate directly to very similar Python code, a feature
that makes it easy to specify PDE problems with lots of PDEs and
complicated terms in the equations.
The language used to express weak forms is called UFL (Unified Form Language)
and is an integral part of FEniCS.</p>
<p>Instead of <code class="docutils literal"><span class="pre">nabla_grad</span></code> we could also just have written
<code class="docutils literal"><span class="pre">grad</span></code> in the examples in this tutorial. However, when taking
gradients of vector fields, <code class="docutils literal"><span class="pre">grad</span></code> and <code class="docutils literal"><span class="pre">nabla_grad</span></code>
differ. The latter is consistent with the tensor algebra commonly
used to derive vector and tensor PDEs, where <span class="math">\(\nabla\)</span> (&#8220;nabla&#8221;) acts as a
vector operator, and therefore this author prefers to always use
<code class="docutils literal"><span class="pre">nabla_grad</span></code>.</p>
<p>Having <code class="docutils literal"><span class="pre">a</span></code> and <code class="docutils literal"><span class="pre">L</span></code> defined, and information about essential
(Dirichlet) boundary conditions in <code class="docutils literal"><span class="pre">bc</span></code>, we can compute the
solution, a finite element function <code class="docutils literal"><span class="pre">u</span></code>, by</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">u</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
<span class="n">solve</span><span class="p">(</span><span class="n">a</span> <span class="o">==</span> <span class="n">L</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">bc</span><span class="p">)</span>
</pre></div>
</div>
<p>Some prefer to replace <code class="docutils literal"><span class="pre">a</span></code> and <code class="docutils literal"><span class="pre">L</span></code> by an <code class="docutils literal"><span class="pre">equation</span></code>
variable, which is accomplished by this equivalent code:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">equation</span> <span class="o">=</span> <span class="n">inner</span><span class="p">(</span><span class="n">nabla_grad</span><span class="p">(</span><span class="n">u</span><span class="p">),</span> <span class="n">nabla_grad</span><span class="p">(</span><span class="n">v</span><span class="p">))</span><span class="o">*</span><span class="n">dx</span> <span class="o">==</span> <span class="n">f</span><span class="o">*</span><span class="n">v</span><span class="o">*</span><span class="n">dx</span>
<span class="n">u</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
<span class="n">solve</span><span class="p">(</span><span class="n">equation</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">bc</span><span class="p">)</span>
</pre></div>
</div>
<p>Note that we first defined the variable <code class="docutils literal"><span class="pre">u</span></code> as a
<code class="docutils literal"><span class="pre">TrialFunction</span></code> and used it to represent the unknown in the form
<code class="docutils literal"><span class="pre">a</span></code>.  Thereafter, we redefined <code class="docutils literal"><span class="pre">u</span></code> to be a <code class="docutils literal"><span class="pre">Function</span></code>
object representing the solution, i.e., the computed finite element
function <span class="math">\(u\)</span>.  This redefinition of the variable <code class="docutils literal"><span class="pre">u</span></code> is possible
in Python and often done in FEniCS applications. The two types of
objects that <code class="docutils literal"><span class="pre">u</span></code> refers to are equal from a mathematical point of
view, and hence it is natural to use the same variable name for both
objects. In a program, however, <code class="docutils literal"><span class="pre">TrialFunction</span></code> objects must
always be used for the unknowns in the problem specification (the form
<code class="docutils literal"><span class="pre">a</span></code>), while <code class="docutils literal"><span class="pre">Function</span></code> objects must be used for quantities
that are computed (known).</p>
<p>The simplest way of quickly looking at <code class="docutils literal"><span class="pre">u</span></code> is to say</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">plot</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">interactive</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="c"># or</span>
<span class="n">plot</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
<span class="n">interactive</span><span class="p">()</span>
</pre></div>
</div>
<p>Clicking on <code class="docutils literal"><span class="pre">Help</span></code> in the plot windows brings up a list of commands.
For example, typing <code class="docutils literal"><span class="pre">m</span></code> brings up the mesh.
With the left, middle, and right
mouse buttons you can rotate, translate, and zoom
(respectively) the plotted surface to better examine what the solution looks
like. You must click <code class="docutils literal"><span class="pre">Ctrl+q</span></code> to kill the plot window and continue
execution beyond the <code class="docutils literal"><span class="pre">plot(u,</span> <span class="pre">interactive=True)</span></code> command or <code class="docutils literal"><span class="pre">interactive()</span></code>.
Figure <a class="reference internal" href="#tut-poisson-2d-fig-ex1-u"><span class="std std-ref">Plot of the solution in the first FEniCS example</span></a>
displays the resulting <span class="math">\(u\)</span> function.</p>
<p>Plotting both the solution and the mesh is accomplished by</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">plot</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
<span class="n">plot</span><span class="p">(</span><span class="n">mesh</span><span class="p">)</span>
<span class="c"># Hold plot</span>
<span class="n">interactive</span><span class="p">()</span>
</pre></div>
</div>
<p>Type <code class="docutils literal"><span class="pre">Ctrl+w</span></code> to kill all plot windows and continue execution.</p>
<p>It is also possible to dump the computed solution to file, e.g., in the
VTK format:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="nb">file</span> <span class="o">=</span> <span class="n">File</span><span class="p">(</span><span class="s">&#39;poisson.pvd&#39;</span><span class="p">)</span>
<span class="nb">file</span> <span class="o">&lt;&lt;</span> <span class="n">u</span>
</pre></div>
</div>
<p>The <code class="docutils literal"><span class="pre">poisson.pvd</span></code> file can now be loaded into any
front-end to VTK, say ParaView or VisIt. The <code class="docutils literal"><span class="pre">plot</span></code> function
is intended for quick examination of the solution during program development.
More in-depth visual investigations of finite element solutions will
normally benefit from using highly professional tools such as ParaView and
VisIt.</p>
<p>The next three sections deal with some technicalities about specifying
the solution method for linear systems (so that you can solve large
problems) and examining array data from the computed solution (so that
you can check that the program is correct).  These technicalities are
scattered around in forthcoming programs. However, the impatient reader who
is more interested in seeing the previous program being adapted to a
real physical problem, and play around with some interesting
visualizations, can safely jump to the section <a class="reference internal" href="#tut-poisson-membrane"><span class="std std-ref">Solving a real physical problem</span></a>.
Information in the intermediate sections can be studied on demand.</p>
</div>
</div>
<div class="section" id="controlling-the-solution-process">
<span id="tut-poisson1-solve-prm"></span><h2>Controlling the solution process<a class="headerlink" href="#controlling-the-solution-process" title="Permalink to this headline">¶</a></h2>
<p>Sparse LU decomposition (Gaussian elimination) is used by default to
solve linear systems of equations in FEniCS programs.  This is a very
robust and recommended method for a few thousand unknowns in the
equation system, and may hence be the method of choice in many 2D and
smaller 3D problems. However, sparse LU decomposition becomes slow and
memory demanding in large problems.  This fact forces the use of
iterative methods, which are faster and require much less memory.</p>
<p id="index-19">Preconditioned Krylov solvers is a type of popular iterative methods that are
easily accessible in FEniCS programs. The Poisson equation results in
a symmetric, positive definite coefficient matrix, for which the optimal
Krylov solver is the Conjugate Gradient (CG) method. However, the
CG method requires boundary conditions to be implemented in a
symmetric way. This is not the case by default, so then a Krylov solver
for non-symmetric system, such as GMRES, is a better choice.
Incomplete
LU factorization (ILU) is a popular and
robust all-round preconditioner, so let us try the GMRES-ILU pair:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">solve</span><span class="p">(</span><span class="n">a</span> <span class="o">==</span> <span class="n">L</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">bc</span><span class="p">)</span>
      <span class="n">solver_parameters</span><span class="o">=</span><span class="p">{</span><span class="s">&#39;linear_solver&#39;</span><span class="p">:</span> <span class="s">&#39;gmres&#39;</span><span class="p">,</span>
                         <span class="s">&#39;preconditioner&#39;</span><span class="p">:</span> <span class="s">&#39;ilu&#39;</span><span class="p">})</span>
<span class="c"># Alternative syntax</span>
<span class="n">solve</span><span class="p">(</span><span class="n">a</span> <span class="o">==</span> <span class="n">L</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">bc</span><span class="p">,</span>
      <span class="n">solver_parameters</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">linear_solver</span><span class="o">=</span><span class="s">&#39;gmres&#39;</span><span class="p">,</span>
                             <span class="n">preconditioner</span><span class="o">=</span><span class="s">&#39;ilu&#39;</span><span class="p">))</span>
</pre></div>
</div>
<p>the section <a class="reference internal" href="._ftut007.html#tut-app-solver-prec"><span class="std std-ref">Linear solvers and preconditioners</span></a> lists the most popular choices of
Krylov solvers and preconditioners available in FEniCS.</p>
<span class="target" id="index-20"></span><span class="target" id="index-21"></span><span class="target" id="index-22"></span><span class="target" id="index-23"></span><p id="index-24">The actual GMRES and ILU implementations that are brought into action
depends on the choice of linear algebra package. FEniCS interfaces
several linear algebra packages, called <em>linear algebra backends</em> in
FEniCS terminology.  PETSc is the default choice if DOLFIN is compiled
with PETSc, otherwise uBLAS.  Epetra (Trilinos), Eigen, MTL4 are other
supported backends.  Which backend to apply can be controlled by
setting</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">parameters</span><span class="p">[</span><span class="s">&#39;linear_algebra_backend&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">backendname</span>
</pre></div>
</div>
<p>where <code class="docutils literal"><span class="pre">backendname</span></code> is a string, either <code class="docutils literal"><span class="pre">'Eigen'</span></code>, <code class="docutils literal"><span class="pre">'PETSc'</span></code>, <code class="docutils literal"><span class="pre">'uBLAS'</span></code>,
<code class="docutils literal"><span class="pre">'Epetra'</span></code>, or <code class="docutils literal"><span class="pre">'MTL4'</span></code>.  All these backends offer high-quality
implementations of both iterative and direct solvers for linear systems
of equations.</p>
<p id="index-25">A common platform for FEniCS users is Ubuntu Linux.  The FEniCS
distribution for Ubuntu contains PETSc, making this package the
default linear algebra backend.  The default solver is sparse LU
decomposition (<code class="docutils literal"><span class="pre">'lu'</span></code>), and the actual software that is called is then
the sparse LU solver from UMFPACK (which PETSc has an interface
to). The available linear algebra backends in a FEniCS installation is
listed by</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">list_linear_algebra_backends</span><span class="p">()</span>
</pre></div>
</div>
<span class="target" id="index-26"></span><p id="index-27">We will normally like to control the tolerance in the stopping
criterion and the maximum number of iterations when running an
iterative method.  Such parameters can be set by accessing the <em>global
parameter database</em>, which is called <code class="docutils literal"><span class="pre">parameters</span></code> and which behaves as
a nested dictionary. Write</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">info</span><span class="p">(</span><span class="n">parameters</span><span class="p">,</span> <span class="bp">True</span><span class="p">)</span>
</pre></div>
</div>
<p>to list all parameters and their default values in the database.
The nesting of parameter sets is indicated through indentation in the
output from <code class="docutils literal"><span class="pre">info</span></code>.
According to this output, the relevant parameter set is
named <code class="docutils literal"><span class="pre">'krylov_solver'</span></code>, and the parameters are set like this:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">prm</span> <span class="o">=</span> <span class="n">parameters</span><span class="p">[</span><span class="s">&#39;krylov_solver&#39;</span><span class="p">]</span> <span class="c"># short form</span>
<span class="n">prm</span><span class="p">[</span><span class="s">&#39;absolute_tolerance&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1E-10</span>
<span class="n">prm</span><span class="p">[</span><span class="s">&#39;relative_tolerance&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1E-6</span>
<span class="n">prm</span><span class="p">[</span><span class="s">&#39;maximum_iterations&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1000</span>
</pre></div>
</div>
<p>Stopping criteria for Krylov solvers usually involve the norm of
the residual, which must be smaller than the absolute tolerance
parameter <em>or</em> smaller than the relative tolerance parameter times
the initial residual.</p>
<p>To see the number of actual iterations to reach the stopping criterion,
we can insert</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">set_log_level</span><span class="p">(</span><span class="n">PROGRESS</span><span class="p">)</span>
<span class="c"># or</span>
<span class="n">set_log_level</span><span class="p">(</span><span class="n">DEBUG</span><span class="p">)</span>
</pre></div>
</div>
<p>A message with the equation system size, solver type, and number of
iterations arises from specifying the argument <code class="docutils literal"><span class="pre">PROGRESS</span></code>, while
<code class="docutils literal"><span class="pre">DEBUG</span></code> results in more information, including CPU time spent in
the various parts of the matrix assembly and solve process.</p>
<p>The complete solution process with control of the solver parameters
now contains the statements</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">prm</span> <span class="o">=</span> <span class="n">parameters</span><span class="p">[</span><span class="s">&#39;krylov_solver&#39;</span><span class="p">]</span> <span class="c"># short form</span>
<span class="n">prm</span><span class="p">[</span><span class="s">&#39;absolute_tolerance&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1E-10</span>
<span class="n">prm</span><span class="p">[</span><span class="s">&#39;relative_tolerance&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1E-6</span>
<span class="n">prm</span><span class="p">[</span><span class="s">&#39;maximum_iterations&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1000</span>
<span class="n">set_log_level</span><span class="p">(</span><span class="n">PROGRESS</span><span class="p">)</span>

<span class="n">solve</span><span class="p">(</span><span class="n">a</span> <span class="o">==</span> <span class="n">L</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">bc</span><span class="p">,</span>
      <span class="n">solver_parameters</span><span class="o">=</span><span class="p">{</span><span class="s">&#39;linear_solver&#39;</span><span class="p">:</span> <span class="s">&#39;gmres&#39;</span><span class="p">,</span>
                         <span class="s">&#39;preconditioner&#39;</span><span class="p">:</span> <span class="s">&#39;ilu&#39;</span><span class="p">})</span>
</pre></div>
</div>
<p>The demo program <code class="docutils literal"><span class="pre">d2_p2D.py</span></code> in the <code class="docutils literal"><span class="pre">stationary/poisson</span></code> directory
incorporates the above shown control of the linear solver and
preconditioner, but is otherwise similar to the previous <code class="docutils literal"><span class="pre">d1_p2D.py</span></code>
program.</p>
<p>We remark that default values for the global parameter database can be
defined in an XML file. To generate such a file from the current set
of parameters in a program, run</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">File</span><span class="p">(</span><span class="s">&#39;dolfin_parameters.xml&#39;</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">parameters</span>
</pre></div>
</div>
<p>If a <code class="docutils literal"><span class="pre">dolfin_parameters.xml</span></code> file is
found in the directory where a FEniCS program is run, this file is
read and used to initialize the <code class="docutils literal"><span class="pre">parameters</span></code> object. Otherwise,
the file <code class="docutils literal"><span class="pre">.config/fenics/dolfin_parameters.xml</span></code> in the user&#8217;s home
directory is read, if it exists.  Another alternative is to load
the XML (with any name) manually in the program:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">File</span><span class="p">(</span><span class="s">&#39;dolfin_parameters.xml&#39;</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">parameters</span>
</pre></div>
</div>
<p>The XML file can also be in gzip&#8217;ed form with the extension <code class="docutils literal"><span class="pre">.xml.gz</span></code>.</p>
</div>
<div class="section" id="linear-variational-problem-and-solver-objects">
<span id="tut-poisson1-solver-problem"></span><h2>Linear variational problem and solver objects<a class="headerlink" href="#linear-variational-problem-and-solver-objects" title="Permalink to this headline">¶</a></h2>
<span class="target" id="index-28"></span><span class="target" id="index-29"></span><p id="index-30">The <code class="docutils literal"><span class="pre">solve(a</span> <span class="pre">==</span> <span class="pre">L,</span> <span class="pre">u,</span> <span class="pre">bc)</span></code> call is just a compact syntax alternative to a
slightly more comprehensive specification of the variational equation
and the solution of the associated linear system.  This alternative
syntax is used in a lot of FEniCS applications and will also be
used later in this tutorial, so we show it already now:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">u</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
<span class="n">problem</span> <span class="o">=</span> <span class="n">LinearVariationalProblem</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">bc</span><span class="p">)</span>
<span class="n">solver</span>  <span class="o">=</span> <span class="n">LinearVariationalSolver</span><span class="p">(</span><span class="n">problem</span><span class="p">)</span>
<span class="n">solver</span><span class="o">.</span><span class="n">solve</span><span class="p">()</span>
</pre></div>
</div>
<p>Many objects have an attribute <code class="docutils literal"><span class="pre">parameters</span></code> corresponding to
a parameter set in the global <code class="docutils literal"><span class="pre">parameters</span></code> database,
but local to the object. Here, <code class="docutils literal"><span class="pre">solver.parameters</span></code> play that
role. Setting the CG method with ILU preconditioning as solution
method and specifying solver-specific parameters can be done
like this:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">solver</span><span class="o">.</span><span class="n">parameters</span><span class="p">[</span><span class="s">&#39;linear_solver&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;cg&#39;</span>
<span class="n">solver</span><span class="o">.</span><span class="n">parameters</span><span class="p">[</span><span class="s">&#39;preconditioner&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;ilu&#39;</span>
<span class="n">cg_prm</span> <span class="o">=</span> <span class="n">solver</span><span class="o">.</span><span class="n">parameters</span><span class="p">[</span><span class="s">&#39;krylov_solver&#39;</span><span class="p">]</span> <span class="c"># short form</span>
<span class="n">cg_prm</span><span class="p">[</span><span class="s">&#39;absolute_tolerance&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1E-7</span>
<span class="n">cg_prm</span><span class="p">[</span><span class="s">&#39;relative_tolerance&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1E-4</span>
<span class="n">cg_prm</span><span class="p">[</span><span class="s">&#39;maximum_iterations&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1000</span>
</pre></div>
</div>
<p>Calling <code class="docutils literal"><span class="pre">info(solver.parameters,</span> <span class="pre">True)</span></code> lists all the available
parameter sets with default values for each parameter.
Settings in the global <code class="docutils literal"><span class="pre">parameters</span></code> database are
propagated to parameter sets in individual objects, with the
possibility of being overwritten as done above.</p>
<p>The <code class="docutils literal"><span class="pre">d3_p2D.py</span></code> program modifies the <code class="docutils literal"><span class="pre">d2_p2D.py</span></code> file
to incorporate objects for the variational problem and solver.</p>
</div>
<div class="section" id="examining-the-discrete-solution">
<span id="tut-poisson1-verify1"></span><h2>Examining the discrete solution<a class="headerlink" href="#examining-the-discrete-solution" title="Permalink to this headline">¶</a></h2>
<p id="index-31">We know that, in the particular boundary-value problem of the section <a class="reference internal" href="#tut-poisson1-impl"><span class="std std-ref">Implementation</span></a>, the computed solution <span class="math">\(u\)</span> should equal the
exact solution at the vertices of the cells.  An important extension
of our first program is therefore to examine the computed values of
the solution, which is the focus of the present section.</p>
<p id="index-32">A finite element function like <span class="math">\(u\)</span> is expressed as a linear combination
of basis functions <span class="math">\(\phi_j\)</span>, spanning the space <span class="math">\(V\)</span>:</p>
<div class="math" id="eq-tut-poisson1-ufem">
\[\tag{13}
\sum_{j=1}^N U_j \phi_j {\thinspace .}\]</div>
<p>By writing <code class="docutils literal"><span class="pre">solve(a</span> <span class="pre">==</span> <span class="pre">L,</span> <span class="pre">u,</span> <span class="pre">bc)</span></code> in the program, a linear system
will be formed from <span class="math">\(a\)</span> and <span class="math">\(L\)</span>, and this system is solved for the
<span class="math">\(U_1,\ldots,U_N\)</span> values. The <span class="math">\(U_1,\ldots,U_N\)</span> values are known
as <em>degrees of freedom</em> of <span class="math">\(u\)</span>. For Lagrange elements (and many other
element types) <span class="math">\(U_k\)</span> is simply the value of <span class="math">\(u\)</span> at the node
with global number <span class="math">\(k\)</span>.
(The nodes and cell vertices coincide for linear Lagrange elements, while
for higher-order elements there may be additional nodes at
the facets and in the interior of cells.)</p>
<p>Having <code class="docutils literal"><span class="pre">u</span></code> represented as a <code class="docutils literal"><span class="pre">Function</span></code> object, we can either evaluate
<code class="docutils literal"><span class="pre">u(x)</span></code> at any vertex <code class="docutils literal"><span class="pre">x</span></code> in the mesh, or we can grab all the values
<span class="math">\(U_j\)</span> directly by</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">u_nodal_values</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">vector</span><span class="p">()</span>
</pre></div>
</div>
<p>The result is a DOLFIN <code class="docutils literal"><span class="pre">Vector</span></code> object, which is basically an
encapsulation of the vector object used in the linear algebra package
that is used to solve the linear system arising from the
variational problem.
Since we program in Python it is convenient to convert the
<code class="docutils literal"><span class="pre">Vector</span></code> object to a standard <code class="docutils literal"><span class="pre">numpy</span></code> array for further
processing:</p>
<span class="target" id="index-33"></span><div class="highlight-python" id="index-34"><div class="highlight"><pre><span class="n">u_array</span> <span class="o">=</span> <span class="n">u_nodal_values</span><span class="o">.</span><span class="n">array</span><span class="p">()</span>
</pre></div>
</div>
<p>With <code class="docutils literal"><span class="pre">numpy</span></code> arrays we can write MATLAB-like code to analyze
the data. Indexing is done with square brackets: <code class="docutils literal"><span class="pre">u_array[i]</span></code>,
where the index <code class="docutils literal"><span class="pre">i</span></code> always starts at <code class="docutils literal"><span class="pre">0</span></code>.</p>
<p>Now, a fundamental question is: What are the coordinates of
node <code class="docutils literal"><span class="pre">i</span></code> whose value is is <code class="docutils literal"><span class="pre">u_array[i]</span></code>? To answer this question,
we need to understand how to get our hands on the coordinates, and
in particular, the numbering of degrees of freedom and the
numbering of vertices in the mesh. We start with P1
(1st order Lagrange) where all the nodes are vertices in the mesh.</p>
<p>The function <code class="docutils literal"><span class="pre">mesh.coordinates()</span></code> returns the coordinates of the
vertices as a <code class="docutils literal"><span class="pre">numpy</span></code> array with shape <span class="math">\((M,d\)</span>), <span class="math">\(M\)</span> being the number
of vertices in the mesh and <span class="math">\(d\)</span> being the number of space dimensions:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">dolfin</span> <span class="kn">import</span> <span class="o">*</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mesh</span> <span class="o">=</span> <span class="n">UnitSquareMesh</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">coor</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">coordinates</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">coor</span>
<span class="go">array([[ 0. ,  0. ],</span>
<span class="go">       [ 0.5,  0. ],</span>
<span class="go">       [ 1. ,  0. ],</span>
<span class="go">       [ 0. ,  0.5],</span>
<span class="go">       [ 0.5,  0.5],</span>
<span class="go">       [ 1. ,  0.5],</span>
<span class="go">       [ 0. ,  1. ],</span>
<span class="go">       [ 0.5,  1. ],</span>
<span class="go">       [ 1. ,  1. ]])</span>
</pre></div>
</div>
<p>We see from this output that vertices are first numbered along <span class="math">\(y=0\)</span>
with increasing <span class="math">\(x\)</span> coordinate, then along <span class="math">\(y=0.5\)</span>, and so on.</p>
<p>Next we compute a function <code class="docutils literal"><span class="pre">u</span></code> on this mesh, e.g., the <span class="math">\(u=x+y\)</span>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">V</span> <span class="o">=</span> <span class="n">FunctionSpace</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="s">&#39;CG&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">u</span> <span class="o">=</span> <span class="n">interpolate</span><span class="p">(</span><span class="n">Expression</span><span class="p">(</span><span class="s">&#39;x[0]+x[1]&#39;</span><span class="p">),</span> <span class="n">V</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">u_array</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">vector</span><span class="p">()</span><span class="o">.</span><span class="n">array</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">u_array</span>
<span class="go">array([ 1. ,  0.5,  1.5,  0. ,  1. ,  2. ,  0.5,  1.5,  1. ])</span>
</pre></div>
</div>
<p>We observe that <code class="docutils literal"><span class="pre">u_array[0]</span></code> is <em>not</em> the value of <span class="math">\(x+y\)</span> at vertex number 0,
since this vertex has coordinates <span class="math">\(x=y=0\)</span>. The numbering of the
degrees of freedom <span class="math">\(U_1,\ldots,U_{N}\)</span> is obviously not the same as the
numbering of the vertices.</p>
<p id="index-35">The vertex values of a <code class="docutils literal"><span class="pre">Function</span></code> object can be extracted by
<code class="docutils literal"><span class="pre">u.compute_vertex_values()</span></code>, which returns an array where element <code class="docutils literal"><span class="pre">i</span></code>
is the value of <code class="docutils literal"><span class="pre">u</span></code> at vertex <code class="docutils literal"><span class="pre">i</span></code>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">u_at_vertices</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">compute_vertex_values</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">coor</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">print</span><span class="p">(</span><span class="s">&#39;vertex </span><span class="si">%d</span><span class="s">: u_array[</span><span class="si">%d</span><span class="s">]=</span><span class="si">%g</span><span class="s"> u(</span><span class="si">%s</span><span class="s">)=</span><span class="si">%g</span><span class="s">&#39;</span> <span class="o">%</span>
<span class="gp">... </span>          <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">u_at_vertices</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">x</span><span class="p">,</span> <span class="n">u</span><span class="p">(</span><span class="n">x</span><span class="p">)))</span>
<span class="go">vertex 0: u_array[0]=0 u([ 0.  0.])=8.46545e-16</span>
<span class="go">vertex 1: u_array[1]=0.5 u([ 0.5  0. ])=0.5</span>
<span class="go">vertex 2: u_array[2]=1 u([ 1.  0.])=1</span>
<span class="go">vertex 3: u_array[3]=0.5 u([ 0.   0.5])=0.5</span>
<span class="go">vertex 4: u_array[4]=1 u([ 0.5  0.5])=1</span>
<span class="go">vertex 5: u_array[5]=1.5 u([ 1.   0.5])=1.5</span>
<span class="go">vertex 6: u_array[6]=1 u([ 0.  1.])=1</span>
<span class="go">vertex 7: u_array[7]=1.5 u([ 0.5  1. ])=1.5</span>
<span class="go">vertex 8: u_array[8]=2 u([ 1.  1.])=2</span>
</pre></div>
</div>
<span class="target" id="index-36"></span><p id="index-37">Alternatively, we can ask for the mapping from vertex numbering to degrees
of freedom numbering in the space <span class="math">\(V\)</span>:</p>
<div class="highlight-text"><div class="highlight"><pre>v2d = vertex_to_dof_map(V)
</pre></div>
</div>
<p>Now, <code class="docutils literal"><span class="pre">u_array[v2d[i]]</span></code> will give us the value of the
degree of freedom in <code class="docutils literal"><span class="pre">u</span></code> corresponding
to vertex <code class="docutils literal"><span class="pre">i</span></code> (<code class="docutils literal"><span class="pre">v2d[i]</span></code>). In particular, <code class="docutils literal"><span class="pre">u_array[v2d]</span></code> is an array
with all the elements in the same (vertex numbered) order as <code class="docutils literal"><span class="pre">coor</span></code>.
The inverse map, from degrees of freedom
number to vertex number is given by <code class="docutils literal"><span class="pre">dof_to_vertex_map(V)</span></code>, so
<code class="docutils literal"><span class="pre">coor[dof_to_vertex_map(V)]</span></code> results in an array of all the
coordinates in the same order as the degrees of freedom.</p>
<p>For Lagrange elements of degree larger than 1, there are degrees of
freedom (nodes) that do not correspond to vertices.
[<strong>hpl 1</strong>: Anders, is this true?] There is no simple way of getting the
coordinates associated with the non-vertex degrees of freedom, so
if we want to write out the values of a finite element solution,
the following code snippet does the task at the vertices, and this
will work for all kinds of Lagrange elements.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">u_at_vertices</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">compute_vertex_values</span><span class="p">()</span>
<span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">coor</span><span class="p">):</span>
    <span class="k">print</span><span class="p">(</span><span class="s">&#39;u(</span><span class="si">%8g</span><span class="s">,</span><span class="si">%8g</span><span class="s">) = </span><span class="si">%g</span><span class="s">&#39;</span> <span class="o">%</span>
          <span class="p">(</span><span class="n">coor</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">coor</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="n">u_at_vertices</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
</pre></div>
</div>
<p>The beginning of the output looks like this:</p>
<div class="highlight-text"><div class="highlight"><pre>u(       0,       0) = 1
u(0.166667,       0) = 1.02778
u(0.333333,       0) = 1.11111
u(     0.5,       0) = 1.25
u(0.666667,       0) = 1.44444
u(0.833333,       0) = 1.69444
u(       1,       0) = 2
</pre></div>
</div>
<p>For Lagrange elements of degree higher than one, the vertices do not
correspond to all the nodal points and the <code class="docutils literal"><span class="pre">if</span></code>-test fails.</p>
<p>For verification purposes we want to compare the values of the
computed <code class="docutils literal"><span class="pre">u</span></code> at the nodes (given by <code class="docutils literal"><span class="pre">u_array</span></code>) with the exact
solution <code class="docutils literal"><span class="pre">u0</span></code> evaluated at the nodes.  The difference between the
computed and exact solution should be less than a small tolerance at
all the nodes. The <code class="docutils literal"><span class="pre">Expression</span></code> object <code class="docutils literal"><span class="pre">u0</span></code> can be evaluated
at any point <code class="docutils literal"><span class="pre">x</span></code> by calling <code class="docutils literal"><span class="pre">u0(x)</span></code>. Specifically,
<code class="docutils literal"><span class="pre">u0(coor[i])</span></code> returns the value of <code class="docutils literal"><span class="pre">u0</span></code> at the vertex or node
with global number <code class="docutils literal"><span class="pre">i</span></code>.</p>
<span class="target" id="index-38"></span><p id="index-39">Alternatively, we can make a finite element field <code class="docutils literal"><span class="pre">u_e</span></code>, representing
the exact solution, whose values at the nodes are given by the
<code class="docutils literal"><span class="pre">u0</span></code> function. With mathematics, <span class="math">\({u_{\small\mbox{e}}} = \sum_{j=1}^N  E_j\phi_j\)</span>, where
<span class="math">\(E_j=u_0(x_j,y_j)\)</span>, <span class="math">\((x_j,y_j)\)</span> being the coordinates of node number <span class="math">\(j\)</span>.
This process is known as interpolation.
FEniCS has a function for performing the operation:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">u_e</span> <span class="o">=</span> <span class="n">interpolate</span><span class="p">(</span><span class="n">u0</span><span class="p">,</span> <span class="n">V</span><span class="p">)</span>
</pre></div>
</div>
<p>The maximum error can now be computed as</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">u_e_array</span> <span class="o">=</span> <span class="n">u_e</span><span class="o">.</span><span class="n">vector</span><span class="p">()</span><span class="o">.</span><span class="n">array</span><span class="p">()</span>
<span class="k">print</span><span class="p">(</span><span class="s">&#39;Max error:&#39;</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">u_e_array</span> <span class="o">-</span> <span class="n">u_array</span><span class="p">)</span><span class="o">.</span><span class="n">max</span><span class="p">())</span>
</pre></div>
</div>
<p>The value of the error should be at the level of the machine precision
(<span class="math">\(10^{-16}\)</span>).</p>
<p>To demonstrate the use of point evaluations of <code class="docutils literal"><span class="pre">Function</span></code> objects,
we write out the computed <code class="docutils literal"><span class="pre">u</span></code> at the center point
of the domain and compare it with the exact solution:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">center</span> <span class="o">=</span> <span class="p">(</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="s">&#39;numerical u at the center point:&#39;</span><span class="p">,</span>  <span class="n">u</span><span class="p">(</span><span class="n">center</span><span class="p">))</span>
<span class="k">print</span><span class="p">(</span><span class="s">&#39;exact     u at the center point:&#39;</span><span class="p">,</span> <span class="n">u0</span><span class="p">(</span><span class="n">center</span><span class="p">))</span>
</pre></div>
</div>
<p>Trying a <span class="math">\(3\times 3\)</span> mesh, the output from the
previous snippet becomes</p>
<div class="highlight-text"><div class="highlight"><pre>numerical u at the center point: [ 1.83333333]
exact     u at the center point: [ 1.75]
</pre></div>
</div>
<p>The discrepancy is due to the fact that the center point is not a node
in this particular mesh, but a point in the interior of a cell,
and <code class="docutils literal"><span class="pre">u</span></code> varies linearly over the cell while
<code class="docutils literal"><span class="pre">u0</span></code> is a quadratic function.</p>
<p>We have seen how to extract the nodal values in a <code class="docutils literal"><span class="pre">numpy</span></code> array.
If desired, we can adjust the nodal values too. Say we want to
normalize the solution such that <span class="math">\(\max_j U_j = 1\)</span>. Then we
must divide all <span class="math">\(U_j\)</span> values
by <span class="math">\(\max_j U_j\)</span>. The following snippet performs the task:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">max_u</span> <span class="o">=</span> <span class="n">u_array</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
<span class="n">u_array</span> <span class="o">/=</span> <span class="n">max_u</span>
<span class="n">u</span><span class="o">.</span><span class="n">vector</span><span class="p">()[:]</span> <span class="o">=</span> <span class="n">u_array</span>
<span class="n">u</span><span class="o">.</span><span class="n">vector</span><span class="p">()</span><span class="o">.</span><span class="n">set_local</span><span class="p">(</span><span class="n">u_array</span><span class="p">)</span>  <span class="c"># alternative</span>
<span class="k">print</span><span class="p">(</span><span class="n">u</span><span class="o">.</span><span class="n">vector</span><span class="p">()</span><span class="o">.</span><span class="n">array</span><span class="p">())</span>
</pre></div>
</div>
<p>That is, we manipulate <code class="docutils literal"><span class="pre">u_array</span></code> as desired, and then we insert this
array into <code class="docutils literal"><span class="pre">u</span></code>&#8216;s <code class="docutils literal"><span class="pre">Vector</span></code> object.  The <code class="docutils literal"><span class="pre">/=</span></code> operator implies an
in-place modification of the object on the left-hand side: all
elements of the <code class="docutils literal"><span class="pre">u_array</span></code> are divided by the value <code class="docutils literal"><span class="pre">max_u</span></code>.
Alternatively, one could write <code class="docutils literal"><span class="pre">u_array</span> <span class="pre">=</span> <span class="pre">u_array/max_u</span></code>, which
implies creating a new array on the right-hand side and assigning this
array to the name <code class="docutils literal"><span class="pre">u_array</span></code>.</p>
<p>A call like <code class="docutils literal"><span class="pre">u.vector().array()</span></code> returns a copy of the data in
<code class="docutils literal"><span class="pre">u.vector()</span></code>. One must therefore never perform assignments like
<code class="docutils literal"><span class="pre">u.vector.array()[:]</span> <span class="pre">=</span> <span class="pre">...</span></code>, but instead extract the <code class="docutils literal"><span class="pre">numpy</span></code> array
(i.e., a copy), manipulate it, and insert it back with <code class="docutils literal"><span class="pre">u.vector()[:]</span>
<span class="pre">=</span> <span class="pre">``</span> <span class="pre">or</span> <span class="pre">``u.set_local(...)</span></code>.
[[[</p>
<p>There is more mesh information to be gathered from a <code class="docutils literal"><span class="pre">mesh</span></code> object:</p>
<blockquote>
<div><ul class="simple">
<li><code class="docutils literal"><span class="pre">mesh.num_cells()</span></code> returns the number of cells (triangles)
in the mesh,</li>
<li><code class="docutils literal"><span class="pre">mesh.num_vertices()</span></code> returns the number of vertices in
the mesh (with our choice of linear Lagrange elements this equals the
number of nodes, <code class="docutils literal"><span class="pre">len(u_array)</span></code>, or dimension of the space <code class="docutils literal"><span class="pre">V.dim()</span></code>),</li>
<li><code class="docutils literal"><span class="pre">mesh.cells()</span></code> returns the vertex numbers of the vertices in
each cell as a <code class="docutils literal"><span class="pre">numpy</span></code> array with shape
(<em>number of cells</em>, <em>number of vertices in a cell</em>),</li>
<li><code class="docutils literal"><span class="pre">mesh.hmin()</span></code> returns the minimum cell diameter (&#8220;smallest cell&#8221;),</li>
<li><code class="docutils literal"><span class="pre">mesh.hmax()</span></code> returns the maximum cell diameter (&#8220;largest cell&#8221;).</li>
</ul>
</div></blockquote>
<p>Writing <code class="docutils literal"><span class="pre">print(mesh)</span></code> dumps a short, pretty-print description
of the mesh (<code class="docutils literal"><span class="pre">print(mesh)</span></code> actually displays the result of <code class="docutils literal"><span class="pre">str(mesh)</span></code>,
which defines the pretty print):</p>
<div class="highlight-text"><div class="highlight"><pre>&lt;Mesh of topological dimension 2 (triangles) with
16 vertices and 18 cells, ordered&gt;
</pre></div>
</div>
<p id="index-40">All mesh objects are of type <code class="docutils literal"><span class="pre">Mesh</span></code> so typing the command
<code class="docutils literal"><span class="pre">pydoc</span> <span class="pre">dolfin.Mesh</span></code> in a terminal window will give a list
of methods (that is, functions in a class)
that can be called through any <code class="docutils literal"><span class="pre">Mesh</span></code> object. In fact,
<code class="docutils literal"><span class="pre">pydoc</span> <span class="pre">dolfin.X</span></code> shows the documentation of any DOLFIN name <code class="docutils literal"><span class="pre">X</span></code>.</p>
<p>All the code in this subsection can be found in the file <code class="docutils literal"><span class="pre">d4_p2D.py</span></code>
in the <code class="docutils literal"><span class="pre">stationary/poisson</span></code> directory.  We have commented out the
plotting statements in this version of the program, but if you want
plotting to happen, make sure that <code class="docutils literal"><span class="pre">interactive</span></code> is called at the very
end of the program.</p>
</div>
<div class="section" id="solving-a-real-physical-problem">
<span id="tut-poisson-membrane"></span><h2>Solving a real physical problem<a class="headerlink" href="#solving-a-real-physical-problem" title="Permalink to this headline">¶</a></h2>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">The program example in this section relies on generating a mesh over
a circular disk. This must be done with a preprocessor.</p>
</div>
<p>Perhaps you are not particularly amazed by viewing the simple surface
of <span class="math">\(u\)</span> in the test problem from the section <a class="reference internal" href="#tut-poisson1-impl"><span class="std std-ref">Implementation</span></a>.
However, solving a real physical problem
with a more interesting and amazing solution on the screen is only a
matter of specifying a more exciting domain, boundary condition,
and/or right-hand side <span class="math">\(f\)</span>.</p>
<p>One possible physical problem regards the deflection <span class="math">\(D(x,y)\)</span> of an
elastic circular membrane with radius <span class="math">\(R\)</span>, subject to a localized
perpendicular pressure force, modeled as a Gaussian function.  The
appropriate PDE model is</p>
<div class="math" id="eq-auto3">
\[\tag{14}
-T\nabla^2 D = p(x,y)\quad\hbox{in }\Omega = \{ (x,y)\,|\, x^2+y^2\leq R\},\]</div>
<p>with</p>
<div class="math" id="eq-auto4">
\[\tag{15}
p(x,y) = {A\over 2\pi\sigma}\exp{\left(
    - {1\over2}\left( {x-x_0\over\sigma}\right)^2
    - {1\over2}\left( {y-y_0\over\sigma}\right)^2
    \right)}\, .\]</div>
<p>Here, <span class="math">\(T\)</span> is the tension in the membrane (constant), <span class="math">\(p\)</span> is the external
pressure load,
<span class="math">\(A\)</span> the amplitude of the pressure, <span class="math">\((x_0,y_0)\)</span> the localization of
the Gaussian pressure function, and <span class="math">\(\sigma\)</span> the &#8220;width&#8221; of this
function. The boundary of the membrane has no
deflection, implying <span class="math">\(D=0\)</span> as boundary condition.</p>
<p>For scaling and verification it is convenient to simplify the problem
to find an analytical solution. In the limit <span class="math">\(\sigma\rightarrow\infty\)</span>,
<span class="math">\(p\rightarrow A/(2\pi\sigma)\)</span> (constant pressure throughout <span class="math">\(\Omega\)</span>),
which allows us to integrate an axi-symmetric
version of the equation in the radial coordinate <span class="math">\(r\in [0,R]\)</span> and
obtain <span class="math">\(D(r)=(r^2-R^2)A/(8\pi\sigma T)\)</span>. This result gives
a rough estimate of the characteristic size of the deflection:
<span class="math">\(|D(0)|=AR^2/(8\pi\sigma T)\)</span>, which can be used to scale the deflection.
With <span class="math">\(R\)</span> as characteristic length scale, we can derive the equivalent
dimensionless problem on the unit circle,</p>
<div class="math" id="eq-tut-poisson1-membrane-scaled-eq">
\[\tag{16}
-\nabla^2 w = f,\]</div>
<p>with <span class="math">\(w=0\)</span> on the boundary and with</p>
<div class="math" id="eq-tut-poisson1-membrane-scaled-eq-rhs">
\[\tag{17}
\
    f(x,y) = 4\exp{\left(
    - \frac{1}{2}\left( \frac{Rx-x_0}{\sigma}\right)^2
    - \frac{1}{2}\left( \frac{Ry-y_0}{\sigma}\right)^2
    \right)}.\]</div>
<p>For notational convenience we have dropped introducing new symbols
for the scaled
coordinates in <a class="reference internal" href="#eq-tut-poisson1-membrane-scaled-eq-rhs"><span class="std std-ref">(17)</span></a>.
Now <span class="math">\(D\)</span> is related to <span class="math">\(w\)</span> through <span class="math">\(D = AR^2w/(8\pi\sigma T)\)</span>.</p>
<p>Let us list the modifications of the
<code class="docutils literal"><span class="pre">d1_p2D.py</span></code> program that are needed to solve this membrane problem:</p>
<blockquote>
<div><ul class="simple">
<li>Initialize <span class="math">\(T\)</span>, <span class="math">\(A\)</span>, <span class="math">\(R\)</span>, <span class="math">\(x_0\)</span>, <span class="math">\(y_0\)</span>, and <span class="math">\(\sigma\)</span>,</li>
<li>create a mesh over the unit circle,</li>
<li>make an expression object for the scaled pressure function <span class="math">\(f\)</span>,</li>
<li>define the <code class="docutils literal"><span class="pre">a</span></code> and <code class="docutils literal"><span class="pre">L</span></code> formulas in the variational
problem for <span class="math">\(w\)</span> and compute the solution,</li>
<li>plot the mesh, <span class="math">\(w\)</span>, and <span class="math">\(f\)</span>,</li>
<li>write out the maximum real deflection <span class="math">\(D\)</span>.</li>
</ul>
</div></blockquote>
<p>Some suitable values of <span class="math">\(T\)</span>, <span class="math">\(A\)</span>, <span class="math">\(R\)</span>, <span class="math">\(x_0\)</span>, <span class="math">\(y_0\)</span>, and <span class="math">\(\sigma\)</span> are</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">T</span> <span class="o">=</span> <span class="mf">10.0</span>  <span class="c"># tension</span>
<span class="n">A</span> <span class="o">=</span> <span class="mf">1.0</span>   <span class="c"># pressure amplitude</span>
<span class="n">R</span> <span class="o">=</span> <span class="mf">0.3</span>   <span class="c"># radius of domain</span>
<span class="n">theta</span> <span class="o">=</span> <span class="mf">0.2</span>
<span class="n">x0</span> <span class="o">=</span> <span class="mf">0.6</span><span class="o">*</span><span class="n">R</span><span class="o">*</span><span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>
<span class="n">y0</span> <span class="o">=</span> <span class="mf">0.6</span><span class="o">*</span><span class="n">R</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>
<span class="n">sigma</span> <span class="o">=</span> <span class="mf">0.025</span>
</pre></div>
</div>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">Meshr must be used to create circle mesh.</p>
</div>
<p>A mesh over the unit circle can be created by</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">mesh</span> <span class="o">=</span> <span class="n">CircleMesh</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
</pre></div>
</div>
<p>where <code class="docutils literal"><span class="pre">n</span></code> is the typical number of elements in the radial direction.</p>
<span class="target" id="index-41"></span><p id="index-42">The function <span class="math">\(f\)</span> is represented by an <code class="docutils literal"><span class="pre">Expression</span></code> object. There
are many physical parameters in the formula for <span class="math">\(f\)</span> that enter the
expression string and these parameters must have their values set
by keyword arguments:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">f</span> <span class="o">=</span> <span class="n">Expression</span><span class="p">(</span><span class="s">&#39;4*exp(-0.5*(pow((R*x[0] - x0)/sigma, 2)) &#39;</span>
               <span class="s">&#39;     - 0.5*(pow((R*x[1] - y0)/sigma, 2)))&#39;</span><span class="p">,</span>
               <span class="n">R</span><span class="o">=</span><span class="n">R</span><span class="p">,</span> <span class="n">x0</span><span class="o">=</span><span class="n">x0</span><span class="p">,</span> <span class="n">y0</span><span class="o">=</span><span class="n">y0</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="n">sigma</span><span class="p">)</span>
</pre></div>
</div>
<p>The coordinates in <code class="docutils literal"><span class="pre">Expression</span></code> objects <em>must</em> be a vector
with indices 0, 1, and 2, and with the name <code class="docutils literal"><span class="pre">x</span></code>. Otherwise
we are free to introduce names of parameters as long as these are
given default values by keyword arguments. All the parameters
initialized by keyword arguments can at any time have their
values modified. For example, we may set</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">f</span><span class="o">.</span><span class="n">sigma</span> <span class="o">=</span> <span class="mi">50</span>
<span class="n">f</span><span class="o">.</span><span class="n">x0</span> <span class="o">=</span> <span class="mf">0.3</span>
</pre></div>
</div>
<p id="index-43">It would be of interest to visualize <span class="math">\(f\)</span> along with <span class="math">\(w\)</span> so that we can
examine the pressure force and its response.  We must then transform
the formula (<code class="docutils literal"><span class="pre">Expression</span></code>) to a finite element function
(<code class="docutils literal"><span class="pre">Function</span></code>).  The most natural approach is to construct a finite
element function whose degrees of freedom (values at the nodes in this case) are
calculated from <span class="math">\(f\)</span>. That is, we interpolate <span class="math">\(f\)</span> (see
the section <a class="reference internal" href="#tut-poisson1-verify1"><span class="std std-ref">Examining the discrete solution</span></a>):</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">f</span> <span class="o">=</span> <span class="n">interpolate</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">V</span><span class="p">)</span>
</pre></div>
</div>
<p>Calling <code class="docutils literal"><span class="pre">plot(f)</span></code> will produce a plot of <span class="math">\(f\)</span>. Note that the assignment
to <code class="docutils literal"><span class="pre">f</span></code> destroys the previous <code class="docutils literal"><span class="pre">Expression</span></code> object <code class="docutils literal"><span class="pre">f</span></code>, so if
it is of interest to still have access to this object, another name must be used
for the <code class="docutils literal"><span class="pre">Function</span></code> object returned by <code class="docutils literal"><span class="pre">interpolate</span></code>.</p>
<p>We need some evidence that the program works, and to this end we may
use the analytical solution listed above for the case
<span class="math">\(\sigma\rightarrow\infty\)</span>. In scaled coordinates the solution reads</p>
<div class="math">
\[w_{\rm}(x,y) = 1-x^2-y^2 .\]</div>
<p>Practical values for an infinite <span class="math">\(\sigma\)</span>
may be 50 or larger, and in such cases the program will report the
maximum deviation between the computed <span class="math">\(w\)</span> and the (approximate) exact
<span class="math">\(w_{\rm e}\)</span>.</p>
<p id="index-44">Note that the variational formulation remains the same as in the
program from the section <a class="reference internal" href="#tut-poisson1-impl"><span class="std std-ref">Implementation</span></a>, except that <span class="math">\(u\)</span> is
replaced by <span class="math">\(w\)</span> and <span class="math">\(u_0=0\)</span>.
The final program is found in the file <code class="docutils literal"><span class="pre">membrane1.py</span></code>, located
in the <code class="docutils literal"><span class="pre">stationary/poisson</span></code> directory, and also listed below.
We have inserted capabilities for iterative solution methods and
hence large meshes (the section <a class="reference internal" href="#tut-poisson1-solve-prm"><span class="std std-ref">Controlling the solution process</span></a>),
used objects for the variational problem and solver
(the section <a class="reference internal" href="#tut-poisson1-solver-problem"><span class="std std-ref">Linear variational problem and solver objects</span></a>), and made numerical
comparison of the numerical and (approximate) analytical solution
(the section <a class="reference internal" href="#tut-poisson1-verify1"><span class="std std-ref">Examining the discrete solution</span></a>).</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">dolfin</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">import</span> <span class="nn">numpy</span>

<span class="c"># This demo needs to be updated for the removal</span>
<span class="c"># of CircleMesh from DOLFIN</span>
<span class="nb">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

<span class="c"># Set pressure function:</span>
<span class="n">T</span> <span class="o">=</span> <span class="mf">10.0</span>  <span class="c"># tension</span>
<span class="n">A</span> <span class="o">=</span> <span class="mf">1.0</span>   <span class="c"># pressure amplitude</span>
<span class="n">R</span> <span class="o">=</span> <span class="mf">0.3</span>   <span class="c"># radius of domain</span>
<span class="n">theta</span> <span class="o">=</span> <span class="mf">0.2</span>
<span class="n">x0</span> <span class="o">=</span> <span class="mf">0.6</span><span class="o">*</span><span class="n">R</span><span class="o">*</span><span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>
<span class="n">y0</span> <span class="o">=</span> <span class="mf">0.6</span><span class="o">*</span><span class="n">R</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>
<span class="n">sigma</span> <span class="o">=</span> <span class="mf">0.025</span>
<span class="c">#sigma = 50  # large value for verification</span>
<span class="n">n</span> <span class="o">=</span> <span class="mi">40</span>   <span class="c"># approx no of elements in radial direction</span>
<span class="n">mesh</span> <span class="o">=</span> <span class="n">CircleMesh</span><span class="p">(</span><span class="n">Point</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">),</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="o">/</span><span class="n">n</span><span class="p">)</span>
<span class="n">V</span> <span class="o">=</span> <span class="n">FunctionSpace</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="s">&#39;Lagrange&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

<span class="c"># Define boundary condition w=0</span>

<span class="k">def</span> <span class="nf">boundary</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">on_boundary</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">on_boundary</span>

<span class="n">bc</span> <span class="o">=</span> <span class="n">DirichletBC</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="n">Constant</span><span class="p">(</span><span class="mf">0.0</span><span class="p">),</span> <span class="n">boundary</span><span class="p">)</span>

<span class="c"># Define variational problem</span>
<span class="n">w</span> <span class="o">=</span> <span class="n">TrialFunction</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
<span class="n">v</span> <span class="o">=</span> <span class="n">TestFunction</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
<span class="n">a</span> <span class="o">=</span> <span class="n">inner</span><span class="p">(</span><span class="n">nabla_grad</span><span class="p">(</span><span class="n">w</span><span class="p">),</span> <span class="n">nabla_grad</span><span class="p">(</span><span class="n">v</span><span class="p">))</span><span class="o">*</span><span class="n">dx</span>
<span class="n">f</span> <span class="o">=</span> <span class="n">Expression</span><span class="p">(</span><span class="s">&#39;4*exp(-0.5*(pow((R*x[0] - x0)/sigma, 2)) &#39;</span>
                     <span class="s">&#39;-0.5*(pow((R*x[1] - y0)/sigma, 2)))&#39;</span><span class="p">,</span>
               <span class="n">R</span><span class="o">=</span><span class="n">R</span><span class="p">,</span> <span class="n">x0</span><span class="o">=</span><span class="n">x0</span><span class="p">,</span> <span class="n">y0</span><span class="o">=</span><span class="n">y0</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="n">sigma</span><span class="p">)</span>
<span class="n">L</span> <span class="o">=</span> <span class="n">f</span><span class="o">*</span><span class="n">v</span><span class="o">*</span><span class="n">dx</span>

<span class="c"># Compute solution</span>
<span class="n">w</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
<span class="n">problem</span> <span class="o">=</span> <span class="n">LinearVariationalProblem</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">bc</span><span class="p">)</span>
<span class="n">solver</span>  <span class="o">=</span> <span class="n">LinearVariationalSolver</span><span class="p">(</span><span class="n">problem</span><span class="p">)</span>
<span class="n">solver</span><span class="o">.</span><span class="n">parameters</span><span class="p">[</span><span class="s">&#39;linear_solver&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;cg&#39;</span>
<span class="n">solver</span><span class="o">.</span><span class="n">parameters</span><span class="p">[</span><span class="s">&#39;preconditioner&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;ilu&#39;</span>
<span class="n">solver</span><span class="o">.</span><span class="n">solve</span><span class="p">()</span>

<span class="c"># Plot scaled solution, mesh and pressure</span>
<span class="n">plot</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="s">&#39;Mesh over scaled domain&#39;</span><span class="p">)</span>
<span class="n">plot</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="s">&#39;Scaled deflection&#39;</span><span class="p">)</span>
<span class="n">f</span> <span class="o">=</span> <span class="n">interpolate</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">V</span><span class="p">)</span>
<span class="n">plot</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="s">&#39;Scaled pressure&#39;</span><span class="p">)</span>

<span class="c"># Find maximum real deflection</span>
<span class="n">max_w</span> <span class="o">=</span> <span class="n">w</span><span class="o">.</span><span class="n">vector</span><span class="p">()</span><span class="o">.</span><span class="n">array</span><span class="p">()</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
<span class="n">max_D</span> <span class="o">=</span> <span class="n">A</span><span class="o">*</span><span class="n">max_w</span><span class="o">/</span><span class="p">(</span><span class="mi">8</span><span class="o">*</span><span class="n">pi</span><span class="o">*</span><span class="n">sigma</span><span class="o">*</span><span class="n">T</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="s">&#39;Maximum real deflection is&#39;</span><span class="p">,</span> <span class="n">max_D</span><span class="p">)</span>

<span class="c"># Verification for &quot;flat&quot; pressure (large sigma)</span>
<span class="k">if</span> <span class="n">sigma</span> <span class="o">&gt;=</span> <span class="mi">50</span><span class="p">:</span>
    <span class="n">w_exact</span> <span class="o">=</span> <span class="n">Expression</span><span class="p">(</span><span class="s">&#39;1 - x[0]*x[0] - x[1]*x[1]&#39;</span><span class="p">)</span>
    <span class="n">w_e</span> <span class="o">=</span> <span class="n">interpolate</span><span class="p">(</span><span class="n">w_exact</span><span class="p">,</span> <span class="n">V</span><span class="p">)</span>
    <span class="n">w_e_array</span> <span class="o">=</span> <span class="n">w_e</span><span class="o">.</span><span class="n">vector</span><span class="p">()</span><span class="o">.</span><span class="n">array</span><span class="p">()</span>
    <span class="n">w_array</span> <span class="o">=</span> <span class="n">w</span><span class="o">.</span><span class="n">vector</span><span class="p">()</span><span class="o">.</span><span class="n">array</span><span class="p">()</span>
    <span class="n">diff_array</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">w_e_array</span> <span class="o">-</span> <span class="n">w_array</span><span class="p">)</span>
    <span class="k">print</span><span class="p">(</span><span class="s">&#39;Verification of the solution, max difference is </span><span class="si">%.4E</span><span class="s">&#39;</span> <span class="o">%</span> \
          <span class="n">diff_array</span><span class="o">.</span><span class="n">max</span><span class="p">())</span>

    <span class="c"># Create finite element field over V and fill with error values</span>
    <span class="n">difference</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
    <span class="n">difference</span><span class="o">.</span><span class="n">vector</span><span class="p">()[:]</span> <span class="o">=</span> <span class="n">diff_array</span>
    <span class="n">plot</span><span class="p">(</span><span class="n">difference</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="s">&#39;Error field for sigma=</span><span class="si">%g</span><span class="s">&#39;</span> <span class="o">%</span> <span class="n">sigma</span><span class="p">)</span>

<span class="c"># Should be at the end</span>
<span class="n">interactive</span><span class="p">()</span>
</pre></div>
</div>
<p>Choosing a small width <span class="math">\(\sigma\)</span> (say 0.01) and a location <span class="math">\((x_0,y_0)\)</span>
toward the circular boundary (say <span class="math">\((0.6R\cos\theta, 0.6R\sin\theta)\)</span>
for any <span class="math">\(\theta\in [0,2\pi]\)</span>), may produce an exciting visual
comparison of <span class="math">\(w\)</span> and <span class="math">\(f\)</span> that demonstrates the very smoothed elastic
response to a peak force (or mathematically, the smoothing properties
of the inverse of the Laplace operator).  One needs to experiment with
the mesh resolution to get a smooth visual representation of&nbsp;<span class="math">\(f\)</span>.  You
are strongly encouraged to play around with the plots and different
mesh resolutions.</p>
</div>
<div class="section" id="quick-visualization-with-vtk">
<span id="tut-quickviz"></span><h2>Quick visualization with VTK<a class="headerlink" href="#quick-visualization-with-vtk" title="Permalink to this headline">¶</a></h2>
<span class="target" id="index-45"></span><span class="target" id="index-46"></span><p id="index-47">As we go along with examples it is fun to play around with
<code class="docutils literal"><span class="pre">plot</span></code> commands and visualize what is computed. This section explains
some useful visualization features.</p>
<p>The <code class="docutils literal"><span class="pre">plot</span></code> command applies the VTK package to visualize finite element
functions in a very quick and simple way.  The command is ideal for
debugging, teaching, and initial scientific investigations.  The
visualization can be interactive, or you can steer and automate it
through program statements.  More advanced and professional
visualizations are usually better created with advanced tools like
Mayavi, ParaView, or VisIt.</p>
<p id="index-48">We have made a program <code class="docutils literal"><span class="pre">membrane1v.py</span></code> for the membrane deflection
problem in the section <a class="reference internal" href="#tut-poisson-membrane"><span class="std std-ref">Solving a real physical problem</span></a> and added various
demonstrations of plotting capabilities. You are encouraged to play around with
<code class="docutils literal"><span class="pre">membrane1v.py</span></code> and modify the code as you read about various features.</p>
<p id="index-49">The <code class="docutils literal"><span class="pre">plot</span></code> function can take additional arguments, such as
a title of the plot, or a specification of a wireframe plot (elevated mesh)
instead of a colored surface plot:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">plot</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="s">&#39;Finite element mesh&#39;</span><span class="p">)</span>
<span class="n">plot</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">wireframe</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="s">&#39;solution&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>The left mouse button is used to rotate the surface, while the right
button can zoom the image in and out.
Point the mouse to the <code class="docutils literal"><span class="pre">Help</span></code> text down in the lower left corner to
get a list of all the keyboard commands that are available.
For example,</p>
<blockquote>
<div><ul class="simple">
<li>pressing <code class="docutils literal"><span class="pre">m</span></code> turns visualization of the mesh on and off,</li>
<li>pressing <code class="docutils literal"><span class="pre">b</span></code> turns on and off a bounding box,</li>
<li>pressing <code class="docutils literal"><span class="pre">p</span></code> dumps the plot to a PNG file,</li>
<li>pressing <code class="docutils literal"><span class="pre">P</span></code> dumps the plot to a PDF file,</li>
<li>pressing <cite>Ctrl +&#8217; stretches the surface in the :math:`z</cite> direction,</li>
<li>pressing <cite>Ctrl -&#8216; shrinks++ the surface in the :math:`z</cite> direction,</li>
<li>pressing <a href="#id1"><span class="problematic" id="id2">`</span></a>Ctrl w&#8217; closes the plot window,</li>
<li>pressing <a href="#id3"><span class="problematic" id="id4">`</span></a>Ctrl q&#8217; closes all plot windows.</li>
</ul>
</div></blockquote>
<p>The plots created by pressing <code class="docutils literal"><span class="pre">p</span></code> or <code class="docutils literal"><span class="pre">P</span></code> are stored in files with
names <code class="docutils literal"><span class="pre">dolfin_plot_X.png</span></code> or <code class="docutils literal"><span class="pre">dolfin_plot_X.pdf</span></code>,
where <code class="docutils literal"><span class="pre">X</span></code> is an integer that is increase by one from the last plot
that was made. The file stem <code class="docutils literal"><span class="pre">dolfin_plot_</span></code> can be set to something
more suitable through the <code class="docutils literal"><span class="pre">prefix</span></code> keyword argument to <code class="docutils literal"><span class="pre">plot</span></code>,
for instance, <code class="docutils literal"><span class="pre">plot(f,</span> <span class="pre">prefix='pressure')</span></code>.</p>
<p>The <code class="docutils literal"><span class="pre">plot</span></code> function takes several other keyword arguments:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">viz_w</span> <span class="o">=</span> <span class="n">plot</span><span class="p">(</span><span class="n">w</span><span class="p">,</span>
             <span class="n">wireframe</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span>
             <span class="n">title</span><span class="o">=</span><span class="s">&#39;Scaled membrane deflection&#39;</span><span class="p">,</span>
             <span class="n">rescale</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span>
             <span class="n">axes</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span>
             <span class="p">)</span>

<span class="n">viz_w</span><span class="o">.</span><span class="n">elevate</span><span class="p">(</span><span class="o">-</span><span class="mi">65</span><span class="p">)</span> <span class="c"># tilt camera -65 degrees (latitude dir)</span>
<span class="n">viz_w</span><span class="o">.</span><span class="n">set_min_max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">max_w</span><span class="p">)</span>
<span class="n">viz_w</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">w</span><span class="p">)</span>    <span class="c"># bring settings above into action</span>
</pre></div>
</div>
<p>Figure <a class="reference internal" href="#tut-poisson-2d-fig1"><span class="std std-ref">Plot of the deflection of a membrane</span></a> shows the resulting scalar surface.</p>
<p>By grabbing the plotting object created by the <code class="docutils literal"><span class="pre">plot</span></code> function we can
create a PNG and PDF plot in the program:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">viz_w</span><span class="o">.</span><span class="n">write_png</span><span class="p">(</span><span class="s">&#39;membrane_deflection&#39;</span><span class="p">)</span>
<span class="n">viz_w</span><span class="o">.</span><span class="n">write_pdf</span><span class="p">(</span><span class="s">&#39;tmp&#39;</span><span class="p">)</span>
<span class="c"># Rotate pdf file (right) from landscape to portrait</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="n">os</span><span class="o">.</span><span class="n">system</span><span class="p">(</span><span class="s">&#39;pdftk tmp.pdf cat 1-endR output membrane_deflection.pdf&#39;</span><span class="p">)</span>
</pre></div>
</div>
<div class="figure" id="id6">
<span id="tut-poisson-2d-fig1"></span><a class="reference internal image-reference" href="_images/membrane_deflection.png"><img alt="_images/membrane_deflection.png" src="_images/membrane_deflection.png" style="width: 480px;" /></a>
<p class="caption"><span class="caption-text"><em>Plot of the deflection of a membrane</em></span></p>
</div>
</div>
<div class="section" id="computing-derivatives">
<span id="tut-poisson-gradu"></span><h2>Computing derivatives<a class="headerlink" href="#computing-derivatives" title="Permalink to this headline">¶</a></h2>
<p>In Poisson and many other problems the gradient of the solution is
of interest. The computation is in principle simple:
since
<span class="math">\(u = \sum_{j=1}^N U_j \phi_j\)</span>, we have that</p>
<div class="math">
\[\nabla u = \sum_{j=1}^N U_j \nabla \phi_j{\thinspace .}\]</div>
<p>Given the solution variable <code class="docutils literal"><span class="pre">u</span></code> in the program, its gradient is
obtained by <code class="docutils literal"><span class="pre">grad(u)</span></code> or <code class="docutils literal"><span class="pre">nabla_grad(u)</span></code>.
However, the gradient of a piecewise continuous
finite element scalar field
is a discontinuous vector field
since the <span class="math">\(\phi_j\)</span> has discontinuous derivatives at the boundaries of
the cells. For example, using Lagrange elements of degree 1, <span class="math">\(u\)</span> is
linear over each cell, and the numerical <span class="math">\(\nabla u\)</span> becomes a piecewise
constant vector field. On the contrary,
the exact gradient is continuous.
For visualization and data analysis purposes
we often want the computed
gradient to be a continuous vector field. Typically,
we want each component of <span class="math">\(\nabla u\)</span> to be represented in the same
way as <span class="math">\(u\)</span> itself. To this end, we can project the components
of <span class="math">\(\nabla u\)</span> onto the
same function space as we used for <span class="math">\(u\)</span>.
This means that we solve <span class="math">\(w = \nabla u\)</span> approximately by a finite element
method, using the same elements for the components of
<span class="math">\(w\)</span> as we used for <span class="math">\(u\)</span>. This process is known as <em>projection</em>.</p>
<p id="index-50">Looking at the component <span class="math">\(\partial
u/\partial x\)</span> of the gradient, we project the (discrete) derivative
<span class="math">\(\sum_jU_j{\partial \phi_j/\partial x}\)</span> onto a function space
with basis <span class="math">\(\phi_1,\phi_2,\ldots\)</span> such that the derivative in
this space is expressed by the standard sum <span class="math">\(\sum_j\bar U_j \phi_j\)</span>,
for suitable (new) coefficients <span class="math">\(\bar U_j\)</span>.</p>
<p>The variational problem for <span class="math">\(w\)</span> reads: find  <span class="math">\(w\in V^{(\mbox{g})}\)</span> such that</p>
<div class="math" id="eq-auto5">
\[\tag{18}
a(w, v) = L(v)\quad\forall v\in \hat{V^{(\mbox{g})}},\]</div>
<p>where</p>
<div class="math" id="eq-auto6">
\[\tag{19}
a(w, v) = \int_\Omega w\cdot v {\, \mathrm{d}x},\]</div>
<div class="math" id="eq-auto7">
\[\tag{20}
L(v) = \int_\Omega \nabla u\cdot v {\, \mathrm{d}x}{\thinspace .}\]</div>
<p>The function spaces <span class="math">\(V^{(\mbox{g})}\)</span> and <span class="math">\(\hat{V^{(\mbox{g})}}\)</span> (with the superscript
g denoting &#8220;gradient&#8221;) are
vector versions of the function space for <span class="math">\(u\)</span>, with
boundary conditions removed (if <span class="math">\(V\)</span> is the
space we used for <span class="math">\(u\)</span>, with no restrictions
on boundary values, <span class="math">\(V^{(\mbox{g})} = \hat{V^{(\mbox{g})}} = [V]^d\)</span>, where
<span class="math">\(d\)</span> is the number of space dimensions).
For example, if we used piecewise linear functions on the mesh to
approximate <span class="math">\(u\)</span>, the variational problem for <span class="math">\(w\)</span> corresponds to
approximating each component field of <span class="math">\(w\)</span> by piecewise linear functions.</p>
<p>The variational problem for the vector field
<span class="math">\(w\)</span>, called <code class="docutils literal"><span class="pre">grad_u</span></code> in the code, is easy to solve in FEniCS:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">V_g</span> <span class="o">=</span> <span class="n">VectorFunctionSpace</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="s">&#39;Lagrange&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">w</span> <span class="o">=</span> <span class="n">TrialFunction</span><span class="p">(</span><span class="n">V_g</span><span class="p">)</span>
<span class="n">v</span> <span class="o">=</span> <span class="n">TestFunction</span><span class="p">(</span><span class="n">V_g</span><span class="p">)</span>

<span class="n">a</span> <span class="o">=</span> <span class="n">inner</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span><span class="o">*</span><span class="n">dx</span>
<span class="n">L</span> <span class="o">=</span> <span class="n">inner</span><span class="p">(</span><span class="n">grad</span><span class="p">(</span><span class="n">u</span><span class="p">),</span> <span class="n">v</span><span class="p">)</span><span class="o">*</span><span class="n">dx</span>
<span class="n">grad_u</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="n">V_g</span><span class="p">)</span>
<span class="n">solve</span><span class="p">(</span><span class="n">a</span> <span class="o">==</span> <span class="n">L</span><span class="p">,</span> <span class="n">grad_u</span><span class="p">)</span>

<span class="n">plot</span><span class="p">(</span><span class="n">grad_u</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="s">&#39;grad(u)&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>The boundary condition argument to <code class="docutils literal"><span class="pre">solve</span></code> is dropped since there are
no essential boundary conditions in this problem.
The new thing is basically that we work with a <code class="docutils literal"><span class="pre">VectorFunctionSpace</span></code>,
since the unknown is now a vector field, instead of the
<code class="docutils literal"><span class="pre">FunctionSpace</span></code> object for scalar fields.
Figure <a class="reference internal" href="#tut-poisson-2d-fig-ex1-gradu"><span class="std std-ref">Example of visualizing the vector field  \( nabla u \)  by arrows at the nodes</span></a> shows
example of how such a vector field is visualized.</p>
<div class="figure" id="id7">
<span id="tut-poisson-2d-fig-ex1-gradu"></span><a class="reference internal image-reference" href="_images/ex1_gradu.png"><img alt="_images/ex1_gradu.png" src="_images/ex1_gradu.png" style="width: 480px;" /></a>
<p class="caption"><span class="caption-text"><em>Example of visualizing the vector field  \( nabla u \)  by arrows at the nodes</em></span></p>
</div>
<p>The scalar component fields of the gradient
can be extracted as separate fields and, e.g., visualized:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">grad_u_x</span><span class="p">,</span> <span class="n">grad_u_y</span> <span class="o">=</span> <span class="n">grad_u</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">deepcopy</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>  <span class="c"># extract components</span>
<span class="n">plot</span><span class="p">(</span><span class="n">grad_u_x</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="s">&#39;x-component of grad(u)&#39;</span><span class="p">)</span>
<span class="n">plot</span><span class="p">(</span><span class="n">grad_u_y</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="s">&#39;y-component of grad(u)&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>The <code class="docutils literal"><span class="pre">deepcopy=True</span></code> argument signifies a <em>deep copy</em>, which is
a general term in computer science implying that a copy of the data is
returned. (The opposite, <code class="docutils literal"><span class="pre">deepcopy=False</span></code>,
means a <em>shallow copy</em>, where
the returned objects are just pointers to the original data.)</p>
<span class="target" id="index-51"></span><span class="target" id="index-52"></span><p id="index-53">The <code class="docutils literal"><span class="pre">grad_u_x</span></code> and <code class="docutils literal"><span class="pre">grad_u_y</span></code> variables behave as
<code class="docutils literal"><span class="pre">Function</span></code> objects. In particular, we can extract the underlying
arrays of nodal values by</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">grad_u_x_array</span> <span class="o">=</span> <span class="n">grad_u_x</span><span class="o">.</span><span class="n">vector</span><span class="p">()</span><span class="o">.</span><span class="n">array</span><span class="p">()</span>
<span class="n">grad_u_y_array</span> <span class="o">=</span> <span class="n">grad_u_y</span><span class="o">.</span><span class="n">vector</span><span class="p">()</span><span class="o">.</span><span class="n">array</span><span class="p">()</span>
</pre></div>
</div>
<p>The degrees of freedom of the <code class="docutils literal"><span class="pre">grad_u</span></code> vector field can also be
reached by</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">grad_u_array</span> <span class="o">=</span> <span class="n">grad_u</span><span class="o">.</span><span class="n">vector</span><span class="p">()</span><span class="o">.</span><span class="n">array</span><span class="p">()</span>
</pre></div>
</div>
<p>but this is a flat <code class="docutils literal"><span class="pre">numpy</span></code> array where the degrees of freedom
for the <span class="math">\(x\)</span> component of the gradient is stored in the first part, then the
degrees of freedom of the <span class="math">\(y\)</span> component, and so on.</p>
<p id="index-54">The program <code class="docutils literal"><span class="pre">d5_p2D.py</span></code> extends the
code <code class="docutils literal"><span class="pre">d5_p2D.py</span></code> from the section <a class="reference internal" href="#tut-poisson1-verify1"><span class="std std-ref">Examining the discrete solution</span></a>
with computations and visualizations of the gradient.
Examining the arrays <code class="docutils literal"><span class="pre">grad_u_x_array</span></code>
and <code class="docutils literal"><span class="pre">grad_u_y_array</span></code>, or looking at the plots of
<code class="docutils literal"><span class="pre">grad_u_x</span></code> and
<code class="docutils literal"><span class="pre">grad_u_y</span></code>, quickly reveals that
the computed <code class="docutils literal"><span class="pre">grad_u</span></code> field does not equal the exact
gradient <span class="math">\((2x, 4y)\)</span> in this particular test problem where <span class="math">\(u=1+x^2+2y^2\)</span>.
There are inaccuracies at the boundaries, arising from the
approximation problem for <span class="math">\(w\)</span>. Increasing the mesh resolution shows,
however, that the components of the gradient vary linearly as
<span class="math">\(2x\)</span> and <span class="math">\(4y\)</span> in
the interior of the mesh (i.e., as soon as we are one element away from
the boundary). See the section <a class="reference internal" href="#tut-quickviz"><span class="std std-ref">Quick visualization with VTK</span></a> for illustrations of
this phenomenon.</p>
<span class="target" id="index-55"></span><p id="index-56">Projecting some function onto some space is a very common
operation in finite element programs. The manual steps in this process
have therefore been collected in a utility function <code class="docutils literal"><span class="pre">project(q,</span> <span class="pre">W)</span></code>,
which returns the projection of some <code class="docutils literal"><span class="pre">Function</span></code> or <code class="docutils literal"><span class="pre">Expression</span></code> object
named <code class="docutils literal"><span class="pre">q</span></code> onto the <code class="docutils literal"><span class="pre">FunctionSpace</span></code> or <code class="docutils literal"><span class="pre">VectorFunctionSpace</span></code> named <code class="docutils literal"><span class="pre">W</span></code>.
Specifically, the previous code for
projecting each component of <code class="docutils literal"><span class="pre">grad(u)</span></code> onto
the same space that we use for <code class="docutils literal"><span class="pre">u</span></code>, can now be done by a one-line call</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">grad_u</span> <span class="o">=</span> <span class="n">project</span><span class="p">(</span><span class="n">grad</span><span class="p">(</span><span class="n">u</span><span class="p">),</span> <span class="n">VectorFunctionSpace</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="s">&#39;Lagrange&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
</pre></div>
</div>
<p>The applications of projection are many, including turning discontinuous
gradient fields into continuous ones, comparing higher- and lower-order
function approximations, and transforming a higher-order finite element
solution down to a piecewise linear field, which is required by many
visualization packages.</p>
</div>
<div class="section" id="a-variable-coefficient-poisson-problem">
<span id="tut-possion-2d-varcoeff"></span><h2>A variable-coefficient poisson problem<a class="headerlink" href="#a-variable-coefficient-poisson-problem" title="Permalink to this headline">¶</a></h2>
<p id="index-57">Suppose we have a variable coefficient <span class="math">\(p(x,y)\)</span> in the Laplace operator,
as in the boundary-value problem</p>
<div class="math" id="eq-tut-poisson-2d-varcoeff">
\[\begin{split}\tag{21}
- \nabla\cdot \left\lbrack
    p(x,y)\nabla u(x,y)\right\rbrack &amp;= f(x,y) \quad \mbox{in } \Omega,
        \\
        u(x,y) &amp;= u_0(x,y) \quad \mbox{on}\  \partial\Omega{\thinspace .}\end{split}\]</div>
<p>We shall quickly demonstrate that this simple extension of our model
problem only requires an equally simple extension of the FEniCS program.</p>
<p>Let us continue to use our favorite solution <span class="math">\(u(x,y)=1+x^2+2y^2\)</span> and
then prescribe <span class="math">\(p(x,y)=x+y\)</span>. It follows that
<span class="math">\(u_0(x,y) = 1 + x^2 + 2y^2\)</span> and <span class="math">\(f(x,y)=-8x-10y\)</span>.</p>
<p id="index-58">What are the modifications we need to do in the <code class="docutils literal"><span class="pre">d4_p2D.py</span></code> program
from the section <a class="reference internal" href="#tut-poisson1-verify1"><span class="std std-ref">Examining the discrete solution</span></a>?</p>
<blockquote>
<div><ul class="simple">
<li><code class="docutils literal"><span class="pre">f</span></code> must be an <code class="docutils literal"><span class="pre">Expression</span></code> since it is no longer a constant,</li>
<li>a new <code class="docutils literal"><span class="pre">Expression</span> <span class="pre">p</span></code> must be defined for the variable coefficient,</li>
<li>the variational problem is slightly changed.</li>
</ul>
</div></blockquote>
<p>First we address the modified variational problem. Multiplying
the PDE by a test function <span class="math">\(v\)</span> and
integrating by parts now results
in</p>
<div class="math">
\[\int_\Omega p\nabla u\cdot\nabla v {\, \mathrm{d}x} -
\int_{\partial\Omega} p{\partial u\over
\partial n}v {\, \mathrm{d}s} = \int_\Omega fv {\, \mathrm{d}x}{\thinspace .}\]</div>
<p>The function spaces for <span class="math">\(u\)</span> and <span class="math">\(v\)</span> are the same as in
the section <a class="reference internal" href="#tut-poisson1-varform"><span class="std std-ref">Variational formulation</span></a>, implying that the boundary integral
vanishes since <span class="math">\(v=0\)</span> on <span class="math">\(\partial\Omega\)</span> where we have Dirichlet conditions.
The weak form <span class="math">\(a(u,v)=L(v)\)</span> then has</p>
<div class="math" id="eq-auto8">
\[\tag{22}
a(u,v) = \int_\Omega p\nabla u\cdot\nabla v {\, \mathrm{d}x},\]</div>
<div class="math" id="eq-auto9">
\[\tag{23}
L(v) = \int_\Omega fv {\, \mathrm{d}x}{\thinspace .}\]</div>
<p>In the code from the section <a class="reference internal" href="#tut-poisson1-impl"><span class="std std-ref">Implementation</span></a> we must replace</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">a</span> <span class="o">=</span> <span class="n">inner</span><span class="p">(</span><span class="n">nabla_grad</span><span class="p">(</span><span class="n">u</span><span class="p">),</span> <span class="n">nabla_grad</span><span class="p">(</span><span class="n">v</span><span class="p">))</span><span class="o">*</span><span class="n">dx</span>
</pre></div>
</div>
<p>by</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">a</span> <span class="o">=</span> <span class="n">p</span><span class="o">*</span><span class="n">inner</span><span class="p">(</span><span class="n">nabla_grad</span><span class="p">(</span><span class="n">u</span><span class="p">),</span> <span class="n">nabla_grad</span><span class="p">(</span><span class="n">v</span><span class="p">))</span><span class="o">*</span><span class="n">dx</span>
</pre></div>
</div>
<p>The definitions of <code class="docutils literal"><span class="pre">p</span></code> and <code class="docutils literal"><span class="pre">f</span></code> read</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">p</span> <span class="o">=</span> <span class="n">Expression</span><span class="p">(</span><span class="s">&#39;x[0] + x[1]&#39;</span><span class="p">)</span>
<span class="n">f</span> <span class="o">=</span> <span class="n">Expression</span><span class="p">(</span><span class="s">&#39;-8*x[0] - 10*x[1]&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>No additional modifications are necessary. The complete code can be
found in the file <code class="docutils literal"><span class="pre">vcp2D.py</span></code> (variable-coefficient Poisson problem in 2D).
You can run it and confirm
that it recovers the exact <span class="math">\(u\)</span> at the nodes.</p>
<p>The flux <span class="math">\(-p\nabla u\)</span> may be of particular interest in
variable-coefficient Poisson problems as it often has an interesting
physical significance. As explained in the section <a class="reference internal" href="#tut-poisson-gradu"><span class="std std-ref">Computing derivatives</span></a>,
we normally want the piecewise discontinuous flux or gradient to be
approximated by a continuous vector field, using the same elements as
used for the numerical solution <span class="math">\(u\)</span>. The approximation now consists of
solving <span class="math">\(w = -p\nabla u\)</span> by a finite element method: find <span class="math">\(w\in V^{(\mbox{g})}\)</span>
such that</p>
<div class="math" id="eq-auto10">
\[\tag{24}
a(w, v) = L(v)\quad\forall v\in \hat{V^{(\mbox{g})}},\]</div>
<p>where</p>
<div class="math" id="eq-auto11">
\[\tag{25}
a(w, v) = \int_\Omega w\cdot v {\, \mathrm{d}x},\]</div>
<div class="math" id="eq-auto12">
\[\tag{26}
L(v) = \int_\Omega (-p \nabla u)\cdot v {\, \mathrm{d}x}{\thinspace .}\]</div>
<p>This problem is identical to the one in the section <a class="reference internal" href="#tut-poisson-gradu"><span class="std std-ref">Computing derivatives</span></a>,
except that <span class="math">\(p\)</span> enters the integral in <span class="math">\(L\)</span>.</p>
<p>The relevant Python statements for computing the flux field take the form</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">V_g</span> <span class="o">=</span> <span class="n">VectorFunctionSpace</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="s">&#39;Lagrange&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">w</span> <span class="o">=</span> <span class="n">TrialFunction</span><span class="p">(</span><span class="n">V_g</span><span class="p">)</span>
<span class="n">v</span> <span class="o">=</span> <span class="n">TestFunction</span><span class="p">(</span><span class="n">V_g</span><span class="p">)</span>

<span class="n">a</span> <span class="o">=</span> <span class="n">inner</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span><span class="o">*</span><span class="n">dx</span>
<span class="n">L</span> <span class="o">=</span> <span class="n">inner</span><span class="p">(</span><span class="o">-</span><span class="n">p</span><span class="o">*</span><span class="n">grad</span><span class="p">(</span><span class="n">u</span><span class="p">),</span> <span class="n">v</span><span class="p">)</span><span class="o">*</span><span class="n">dx</span>
<span class="n">flux</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="n">V_g</span><span class="p">)</span>
<span class="n">solve</span><span class="p">(</span><span class="n">a</span> <span class="o">==</span> <span class="n">L</span><span class="p">,</span> <span class="n">flux</span><span class="p">)</span>
</pre></div>
</div>
<p>The following call to <code class="docutils literal"><span class="pre">project</span></code> is equivalent to the above statements:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">flux</span> <span class="o">=</span> <span class="n">project</span><span class="p">(</span><span class="o">-</span><span class="n">p</span><span class="o">*</span><span class="n">grad</span><span class="p">(</span><span class="n">u</span><span class="p">),</span>
               <span class="n">VectorFunctionSpace</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="s">&#39;Lagrange&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
</pre></div>
</div>
<p>Plotting the flux vector field is naturally as easy as plotting
the gradient (see the section <a class="reference internal" href="#tut-poisson-gradu"><span class="std std-ref">Computing derivatives</span></a>):</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">plot</span><span class="p">(</span><span class="n">flux</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="s">&#39;flux field&#39;</span><span class="p">)</span>

<span class="n">flux_x</span><span class="p">,</span> <span class="n">flux_y</span> <span class="o">=</span> <span class="n">flux</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">deepcopy</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>  <span class="c"># extract components</span>
<span class="n">plot</span><span class="p">(</span><span class="n">flux_x</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="s">&#39;x-component of flux (-p*grad(u))&#39;</span><span class="p">)</span>
<span class="n">plot</span><span class="p">(</span><span class="n">flux_y</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="s">&#39;y-component of flux (-p*grad(u))&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>For data analysis of the nodal values of the flux field we can
grab the underlying <code class="docutils literal"><span class="pre">numpy</span></code> arrays:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">flux_x_array</span> <span class="o">=</span> <span class="n">flux_x</span><span class="o">.</span><span class="n">vector</span><span class="p">()</span><span class="o">.</span><span class="n">array</span><span class="p">()</span>
<span class="n">flux_y_array</span> <span class="o">=</span> <span class="n">flux_y</span><span class="o">.</span><span class="n">vector</span><span class="p">()</span><span class="o">.</span><span class="n">array</span><span class="p">()</span>
</pre></div>
</div>
<p>The program <code class="docutils literal"><span class="pre">vcp2D.py</span></code> contains in addition some plots,
including a curve plot
comparing <code class="docutils literal"><span class="pre">flux_x</span></code> and the exact counterpart along the line <span class="math">\(y=1/2\)</span>.
The associated programming details related to this visualization
are explained in the section <a class="reference internal" href="#tut-structviz"><span class="std std-ref">Visualization of structured mesh data</span></a>.</p>
</div>
<div class="section" id="computing-functionals">
<span id="tut-poisson1-functionals"></span><h2>Computing functionals<a class="headerlink" href="#computing-functionals" title="Permalink to this headline">¶</a></h2>
<p id="index-59">After the solution <span class="math">\(u\)</span> of a PDE is computed, we occasionally want to compute
functionals of <span class="math">\(u\)</span>, for example,</p>
<div class="math" id="eq-tut-poisson1-functionals-energy">
\[\tag{27}
{1\over2}||\nabla u||^2 \equiv {1\over2}\int_\Omega \nabla u\cdot \nabla u {\, \mathrm{d}x},\]</div>
<p>which often reflects some energy quantity.
Another frequently occurring functional is the error</p>
<div class="math" id="eq-tut-poisson1-functionals-error">
\[\tag{28}
||{u_{\small\mbox{e}}}-u|| = \left(\int_\Omega ({u_{\small\mbox{e}}}-u)^2 {\, \mathrm{d}x}\right)^{1/2},\]</div>
<p>where <span class="math">\(u_{\rm e}\)</span> is the exact solution. The error
is of particular interest when studying convergence properties.
Sometimes the interest concerns the flux out of a part <span class="math">\(\Gamma\)</span> of
the boundary <span class="math">\(\partial\Omega\)</span>,</p>
<div class="math" id="eq-tut-poisson1-functionals-flux">
\[\tag{29}
F = -\int_\Gamma p\nabla u\cdot\boldsymbol{n} {\, \mathrm{d}s},\]</div>
<p>where <span class="math">\(\boldsymbol{n}\)</span> is an outward unit normal at <span class="math">\(\Gamma\)</span> and <span class="math">\(p\)</span> is a
coefficient (see the problem in the section <a class="reference internal" href="#tut-possion-2d-varcoeff"><span class="std std-ref">A variable-coefficient poisson problem</span></a>
for a specific example).
All these functionals are easy to compute with FEniCS, and this section
describes how it can be done.</p>
<p id="index-60"><strong>Energy Functional.</strong>
The integrand of the
energy functional
<a class="reference internal" href="#eq-tut-poisson1-functionals-energy"><span class="std std-ref">(27)</span></a>
is described in the UFL language in the same manner as we describe
weak forms:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">energy</span> <span class="o">=</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">inner</span><span class="p">(</span><span class="n">grad</span><span class="p">(</span><span class="n">u</span><span class="p">),</span> <span class="n">grad</span><span class="p">(</span><span class="n">u</span><span class="p">))</span><span class="o">*</span><span class="n">dx</span>
<span class="n">E</span> <span class="o">=</span> <span class="n">assemble</span><span class="p">(</span><span class="n">energy</span><span class="p">)</span>
</pre></div>
</div>
<p>The <code class="docutils literal"><span class="pre">assemble</span></code> call performs the integration.
It is possible to restrict the integration to subdomains, or parts
of the boundary, by using
a mesh function to mark the subdomains as explained in
the section <a class="reference internal" href="._ftut005.html#tut-poisson-mat-neumann"><span class="std std-ref">Multiple Neumann, Robin, and Dirichlet condition</span></a>.
The program <code class="docutils literal"><span class="pre">membrane2.py</span></code> carries out the computation of
the elastic energy</p>
<div class="math" id="index-61">
\[{1\over2}||T\nabla D||^2 = {1\over2}\left({AR\over 8\pi\sigma}\right)^2
||\nabla w||^2\]</div>
<p>in the membrane problem from the section <a class="reference internal" href="#tut-poisson-membrane"><span class="std std-ref">Solving a real physical problem</span></a>.</p>
<p id="index-62"><strong>Convergence Estimation.</strong>
To illustrate error computations and convergence of finite element
solutions, we modify the <code class="docutils literal"><span class="pre">d5_p2D.py</span></code> program from
the section <a class="reference internal" href="#tut-poisson-gradu"><span class="std std-ref">Computing derivatives</span></a> and specify a more complicated solution,</p>
<div class="math">
\[u(x,y) = \sin(\omega\pi x)\sin(\omega\pi y)\]</div>
<p>on the unit square.
This choice implies <span class="math">\(f(x,y)=2\omega^2\pi^2 u(x,y)\)</span>.
With <span class="math">\(\omega\)</span> restricted to an integer
it follows that <span class="math">\(u_0=0\)</span>.</p>
<p id="index-63">We need to define the
appropriate boundary conditions, the exact solution, and the <span class="math">\(f\)</span> function
in the code:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">boundary</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">on_boundary</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">on_boundary</span>

<span class="n">bc</span> <span class="o">=</span> <span class="n">DirichletBC</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="n">Constant</span><span class="p">(</span><span class="mf">0.0</span><span class="p">),</span> <span class="n">boundary</span><span class="p">)</span>

<span class="n">omega</span> <span class="o">=</span> <span class="mf">1.0</span>
<span class="n">u_e</span> <span class="o">=</span> <span class="n">Expression</span><span class="p">(</span><span class="s">&#39;sin(omega*pi*x[0])*sin(omega*pi*x[1])&#39;</span><span class="p">,</span>
                 <span class="n">omega</span><span class="o">=</span><span class="n">omega</span><span class="p">)</span>

<span class="n">f</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">pi</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">omega</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">u_e</span>
</pre></div>
</div>
<p>The computation of
<span class="math">\(\left(\int_\Omega (u_e-u)^2 {\, \mathrm{d}x}\right)^{1/2}\)</span>
can be done by</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">error</span> <span class="o">=</span> <span class="p">(</span><span class="n">u</span> <span class="o">-</span> <span class="n">u_e</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">dx</span>
<span class="n">E</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">assemble</span><span class="p">(</span><span class="n">error</span><span class="p">)))</span>
</pre></div>
</div>
<p>Here, <code class="docutils literal"><span class="pre">u_e</span></code> will be interpolated onto
the function space <code class="docutils literal"><span class="pre">V</span></code>. This implies that the exact solution used in
the integral will vary linearly over
the cells, and not as a sine function,
if <code class="docutils literal"><span class="pre">V</span></code> corresponds to linear Lagrange elements.
This situation may yield a smaller error <code class="docutils literal"><span class="pre">u</span> <span class="pre">-</span> <span class="pre">u_e</span></code> than what is actually true.</p>
<p>Sometimes, for very small error values, the result of <code class="docutils literal"><span class="pre">assemble(error)</span></code>
can be a (very small) negative number,
so we have used <code class="docutils literal"><span class="pre">abs</span></code> in the expression for <code class="docutils literal"><span class="pre">E</span></code> above to ensure a positive
value for the <code class="docutils literal"><span class="pre">sqrt</span></code> function.</p>
<p>More accurate representation of the exact solution is easily achieved
by interpolating the formula onto a space defined by
higher-order elements, say of third degree:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">Ve</span> <span class="o">=</span> <span class="n">FunctionSpace</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="s">&#39;Lagrange&#39;</span><span class="p">,</span> <span class="n">degree</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="n">u_e_Ve</span> <span class="o">=</span> <span class="n">interpolate</span><span class="p">(</span><span class="n">u_e</span><span class="p">,</span> <span class="n">Ve</span><span class="p">)</span>
<span class="n">error</span> <span class="o">=</span> <span class="p">(</span><span class="n">u</span> <span class="o">-</span> <span class="n">u_e_Ve</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">dx</span>
<span class="n">E</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">assemble</span><span class="p">(</span><span class="n">error</span><span class="p">))</span>
</pre></div>
</div>
<p>To achieve complete mathematical
control of which function space the computations are carried out in,
we can explicitly interpolate <code class="docutils literal"><span class="pre">u</span></code> to the same space:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">u_Ve</span> <span class="o">=</span> <span class="n">interpolate</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">Ve</span><span class="p">)</span>
<span class="n">error</span> <span class="o">=</span> <span class="p">(</span><span class="n">u_Ve</span> <span class="o">-</span> <span class="n">u_e_Ve</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">dx</span>
</pre></div>
</div>
<p>The square in the expression for <code class="docutils literal"><span class="pre">error</span></code> will be expanded and lead
to a lot of terms that almost cancel when the error is small, with the
potential of introducing significant round-off errors.
The function <code class="docutils literal"><span class="pre">errornorm</span></code> is available for avoiding this effect
by first interpolating <code class="docutils literal"><span class="pre">u</span></code> and <code class="docutils literal"><span class="pre">u_e</span></code> to a space with
higher-order elements, then subtracting the degrees of freedom, and
then performing the integration of the error field. The usage is simple:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">E</span> <span class="o">=</span> <span class="n">errornorm</span><span class="p">(</span><span class="n">u_e</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">normtype</span><span class="o">=</span><span class="s">&#39;L2&#39;</span><span class="p">,</span> <span class="n">degree</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
</pre></div>
</div>
<p>It is illustrative to look at the short implementation of <code class="docutils literal"><span class="pre">errornorm</span></code>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">errornorm</span><span class="p">(</span><span class="n">u_e</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">Ve</span><span class="p">):</span>
    <span class="n">u_Ve</span> <span class="o">=</span> <span class="n">interpolate</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">Ve</span><span class="p">)</span>
    <span class="n">u_e_Ve</span> <span class="o">=</span> <span class="n">interpolate</span><span class="p">(</span><span class="n">u_e</span><span class="p">,</span> <span class="n">Ve</span><span class="p">)</span>
    <span class="n">e_Ve</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="n">Ve</span><span class="p">)</span>
    <span class="c"># Subtract degrees of freedom for the error field</span>
    <span class="n">e_Ve</span><span class="o">.</span><span class="n">vector</span><span class="p">()[:]</span> <span class="o">=</span> <span class="n">u_e_Ve</span><span class="o">.</span><span class="n">vector</span><span class="p">()</span><span class="o">.</span><span class="n">array</span><span class="p">()</span> <span class="o">-</span> \
                       <span class="n">u_Ve</span><span class="o">.</span><span class="n">vector</span><span class="p">()</span><span class="o">.</span><span class="n">array</span><span class="p">()</span>
    <span class="n">error</span> <span class="o">=</span> <span class="n">e_Ve</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">dx</span>
    <span class="k">return</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">assemble</span><span class="p">(</span><span class="n">error</span><span class="p">))</span>
</pre></div>
</div>
<p>The <code class="docutils literal"><span class="pre">errornorm</span></code> procedure turns out to be identical to computing
the expression <code class="docutils literal"><span class="pre">(u_e</span> <span class="pre">-</span> <span class="pre">u)**2*dx</span></code> directly in
the present test case.</p>
<p>Sometimes it is of interest to compute the error of the
gradient field: <span class="math">\(||\nabla (u-{u_{\small\mbox{e}}})||\)</span>
(often referred to as the <span class="math">\(H^1\)</span> seminorm of the error).
Given the error field <code class="docutils literal"><span class="pre">e_Ve</span></code> above, we simply write</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">H1seminorm</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">assemble</span><span class="p">(</span><span class="n">inner</span><span class="p">(</span><span class="n">grad</span><span class="p">(</span><span class="n">e_Ve</span><span class="p">),</span> <span class="n">grad</span><span class="p">(</span><span class="n">e_Ve</span><span class="p">))</span><span class="o">*</span><span class="n">dx</span><span class="p">))</span>
</pre></div>
</div>
<p>Finally, we remove all <code class="docutils literal"><span class="pre">plot</span></code> calls and printouts of <span class="math">\(u\)</span> values
in the original program, and
collect the computations in a function:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">compute</span><span class="p">(</span><span class="n">nx</span><span class="p">,</span> <span class="n">ny</span><span class="p">,</span> <span class="n">degree</span><span class="p">):</span>
    <span class="n">mesh</span> <span class="o">=</span> <span class="n">UnitSquareMesh</span><span class="p">(</span><span class="n">nx</span><span class="p">,</span> <span class="n">ny</span><span class="p">)</span>
    <span class="n">V</span> <span class="o">=</span> <span class="n">FunctionSpace</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="s">&#39;Lagrange&#39;</span><span class="p">,</span> <span class="n">degree</span><span class="o">=</span><span class="n">degree</span><span class="p">)</span>
    <span class="o">...</span>
    <span class="n">Ve</span> <span class="o">=</span> <span class="n">FunctionSpace</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="s">&#39;Lagrange&#39;</span><span class="p">,</span> <span class="n">degree</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
    <span class="n">E</span> <span class="o">=</span> <span class="n">errornorm</span><span class="p">(</span><span class="n">u_e</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">Ve</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">E</span>
</pre></div>
</div>
<p>Calling <code class="docutils literal"><span class="pre">compute</span></code> for finer and finer meshes enables us to
study the convergence rate. Define the element size
<span class="math">\(h=1/n\)</span>, where <span class="math">\(n\)</span> is the number of divisions in <span class="math">\(x\)</span> and <span class="math">\(y\)</span> direction
(<code class="docutils literal"><span class="pre">nx=ny</span></code> in the code). We perform experiments with <span class="math">\(h_0&gt;h_1&gt;h_2\cdots\)</span>
and compute the corresponding errors <span class="math">\(E_0, E_1, E_3\)</span> and so forth.
Assuming <span class="math">\(E_i=Ch_i^r\)</span> for unknown constants <span class="math">\(C\)</span> and <span class="math">\(r\)</span>, we can compare
two consecutive experiments, <span class="math">\(E_i=Ch_i^r\)</span> and <span class="math">\(E_{i-1}=Ch_{i-1}^r\)</span>,
and solve for <span class="math">\(r\)</span>:</p>
<div class="math">
\[r = {\ln(E_i/E_{i-1})\over\ln (h_i/h_{i-1})}{\thinspace .}\]</div>
<p>The <span class="math">\(r\)</span> values should approach the expected convergence
rate <code class="docutils literal"><span class="pre">degree+1</span></code> as <span class="math">\(i\)</span> increases.</p>
<p>The procedure above can easily be turned into Python code:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">sys</span>
<span class="n">degree</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>  <span class="c"># read degree as 1st command-line arg</span>
<span class="n">h</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c"># element sizes</span>
<span class="n">E</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c"># errors</span>
<span class="k">for</span> <span class="n">nx</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="mi">32</span><span class="p">,</span> <span class="mi">64</span><span class="p">,</span> <span class="mi">128</span><span class="p">,</span> <span class="mi">264</span><span class="p">]:</span>
    <span class="n">h</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mf">1.0</span><span class="o">/</span><span class="n">nx</span><span class="p">)</span>
    <span class="n">E</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">compute</span><span class="p">(</span><span class="n">nx</span><span class="p">,</span> <span class="n">nx</span><span class="p">,</span> <span class="n">degree</span><span class="p">))</span>

<span class="c"># Convergence rates</span>
<span class="kn">from</span> <span class="nn">math</span> <span class="kn">import</span> <span class="n">log</span> <span class="k">as</span> <span class="n">ln</span>  <span class="c"># (log is a dolfin name too - and logg :-)</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">E</span><span class="p">)):</span>
    <span class="n">r</span> <span class="o">=</span> <span class="n">ln</span><span class="p">(</span><span class="n">E</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">/</span><span class="n">E</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span><span class="o">/</span><span class="n">ln</span><span class="p">(</span><span class="n">h</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">/</span><span class="n">h</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
    <span class="k">print</span><span class="p">(</span><span class="s">&#39;h=</span><span class="si">%10.2E</span><span class="s"> r=.2f&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">h</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">r</span><span class="p">))</span>
</pre></div>
</div>
<p>The resulting program has the name <code class="docutils literal"><span class="pre">d6_p2D.py</span></code>
and computes error norms in various ways. Running this
program for elements of first degree and <span class="math">\(\omega=1\)</span> yields the output</p>
<div class="highlight-text"><div class="highlight"><pre>h=1.25E-01 E=3.25E-02 r=1.83
h=6.25E-02 E=8.37E-03 r=1.96
h=3.12E-02 E=2.11E-03 r=1.99
h=1.56E-02 E=5.29E-04 r=2.00
h=7.81E-03 E=1.32E-04 r=2.00
h=3.79E-03 E=3.11E-05 r=2.00
</pre></div>
</div>
<p>That is, we approach the expected second-order convergence of linear
Lagrange elements as the meshes become sufficiently fine.</p>
<p>Running the program for second-degree elements results in the expected
value <span class="math">\(r=3\)</span>,</p>
<div class="highlight-text"><div class="highlight"><pre>h=1.25E-01 E=5.66E-04 r=3.09
h=6.25E-02 E=6.93E-05 r=3.03
h=3.12E-02 E=8.62E-06 r=3.01
h=1.56E-02 E=1.08E-06 r=3.00
h=7.81E-03 E=1.34E-07 r=3.00
h=3.79E-03 E=1.53E-08 r=3.00
</pre></div>
</div>
<p>However, using <code class="docutils literal"><span class="pre">(u</span> <span class="pre">-</span> <span class="pre">u_e)**2</span></code> for the error computation, which
implies interpolating <code class="docutils literal"><span class="pre">u_e</span></code> onto the same space as <code class="docutils literal"><span class="pre">u</span></code>,
results in <span class="math">\(r=4\)</span> (!). This is an example where it is important to
interpolate <code class="docutils literal"><span class="pre">u_e</span></code> to a higher-order space (polynomials of
degree 3 are sufficient here) to avoid computing a too optimistic
convergence rate.</p>
<p>Running the program for third-degree elements results in the
expected value <span class="math">\(r=4\)</span>:</p>
<div class="highlight-text"><div class="highlight"><pre>h=  1.25E-01 r=4.09
h=  6.25E-02 r=4.03
h=  3.12E-02 r=4.01
h=  1.56E-02 r=4.00
h=  7.81E-03 r=4.00
</pre></div>
</div>
<p>Checking convergence rates is the next best method for verifying PDE codes
(the best being exact recovery of a solution as in the section <a class="reference internal" href="#tut-poisson1-verify1"><span class="std std-ref">Examining the discrete solution</span></a> and many other places in this tutorial).</p>
<p id="index-64"><strong>Flux Functionals.</strong>
To compute flux integrals like
<a class="reference internal" href="#eq-tut-poisson1-functionals-flux"><span class="std std-ref">(29)</span></a>
we need to define the <span class="math">\(\boldsymbol{n}\)</span> vector, referred to as <em>facet normal</em>
in FEniCS. If <span class="math">\(\Gamma\)</span> is the complete boundary we can perform
the flux computation by</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">n</span> <span class="o">=</span> <span class="n">FacetNormal</span><span class="p">(</span><span class="n">mesh</span><span class="p">)</span>
<span class="n">flux</span> <span class="o">=</span> <span class="o">-</span><span class="n">p</span><span class="o">*</span><span class="n">dot</span><span class="p">(</span><span class="n">nabla_grad</span><span class="p">(</span><span class="n">u</span><span class="p">),</span> <span class="n">n</span><span class="p">)</span><span class="o">*</span><span class="n">ds</span>
<span class="n">total_flux</span> <span class="o">=</span> <span class="n">assemble</span><span class="p">(</span><span class="n">flux</span><span class="p">)</span>
</pre></div>
</div>
<p>Although <code class="docutils literal"><span class="pre">nabla_grad(u)</span></code> and <code class="docutils literal"><span class="pre">grad(u)</span></code> are interchangeable
in the above expression when <code class="docutils literal"><span class="pre">u</span></code> is a scalar function, we have
chosen to write <code class="docutils literal"><span class="pre">nabla_grad(u)</span></code> because this is
the right expression if we generalize the underlying equation
to a vector Laplace/Poisson PDE. With <code class="docutils literal"><span class="pre">grad(u)</span></code> we must in that
case write <code class="docutils literal"><span class="pre">dot(n,</span> <span class="pre">grad(u))</span></code>.</p>
<p>It is possible to restrict the integration to a part of the boundary
using a mesh function to mark the relevant part, as
explained in the section <a class="reference internal" href="._ftut005.html#tut-poisson-mat-neumann"><span class="std std-ref">Multiple Neumann, Robin, and Dirichlet condition</span></a>. Assuming that the
part corresponds to subdomain number <code class="docutils literal"><span class="pre">i</span></code>, the relevant form for the
flux is <code class="docutils literal"><span class="pre">-p*inner(grad(u),</span> <span class="pre">n)*ds(i)</span></code>.</p>
</div>
<div class="section" id="visualization-of-structured-mesh-data">
<span id="tut-structviz"></span><h2>Visualization of structured mesh data<a class="headerlink" href="#visualization-of-structured-mesh-data" title="Permalink to this headline">¶</a></h2>
<span class="target" id="index-65"></span><span class="target" id="index-66"></span><p id="index-67">When finite element computations are done on a structured rectangular
mesh, maybe with uniform partitioning, VTK-based tools for completely
unstructured 2D/3D meshes are not required.  Instead we can use
visualization and data analysis tools for <em>structured data</em>.
Such data typically appear in finite difference simulations and
image analysis.  Analysis and visualization of structured data are faster
and easier than doing the same with data on unstructured meshes, and
the collection of tools to choose among is much larger.  We shall
demonstrate the potential of such tools and how they allow for
tailored and flexible visualization and data analysis.</p>
<span class="target" id="index-68"></span><p id="index-69">A necessary first step is to transform our <code class="docutils literal"><span class="pre">mesh</span></code> object to an object
representing a rectangle with equally-shaped <em>rectangular</em> cells.  The
Python package <code class="docutils literal"><span class="pre">scitools</span></code> (<a class="reference external" href="https://github.com/hplgit/scitools">https://github.com/hplgit/scitools</a>) has this
type of structure, called a <code class="docutils literal"><span class="pre">UniformBoxMeshGrid</span></code>. The second step is to
transform the one-dimensional array of nodal values to a
two-dimensional array holding the values at the corners of the cells
in the structured grid. In such grids, we want to access a value by
its <span class="math">\(i\)</span> and <span class="math">\(j\)</span> indices, <span class="math">\(i\)</span> counting cells in the <span class="math">\(x\)</span> direction, and
<span class="math">\(j\)</span> counting cells in the <span class="math">\(y\)</span> direction.  This transformation is in
principle straightforward, yet it frequently leads to obscure indexing
errors. The <code class="docutils literal"><span class="pre">BoxField</span></code> object in <code class="docutils literal"><span class="pre">scitools</span></code> takes conveniently care of
the details of the transformation.  With a <code class="docutils literal"><span class="pre">BoxField</span></code> defined on a
<code class="docutils literal"><span class="pre">UniformBoxMeshGrid</span></code> it is very easy to call up more standard plotting
packages to visualize the solution along lines in the domain or as 2D
contours or lifted surfaces.</p>
<p>Let us go back to the <code class="docutils literal"><span class="pre">vcp2D.py</span></code> code from
the section <a class="reference internal" href="#tut-possion-2d-varcoeff"><span class="std std-ref">A variable-coefficient poisson problem</span></a> and map <code class="docutils literal"><span class="pre">u</span></code> onto a
<code class="docutils literal"><span class="pre">BoxField</span></code> object:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">scitools.BoxField</span>
<span class="n">u2</span> <span class="o">=</span> <span class="n">u</span> <span class="k">if</span> <span class="n">u</span><span class="o">.</span><span class="n">ufl_element</span><span class="p">()</span><span class="o">.</span><span class="n">degree</span><span class="p">()</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span> \
     <span class="n">interpolate</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">FunctionSpace</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="s">&#39;Lagrange&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
<span class="n">u_box</span> <span class="o">=</span> <span class="n">scitools</span><span class="o">.</span><span class="n">BoxField</span><span class="o">.</span><span class="n">dolfin_function2BoxField</span><span class="p">(</span>
        <span class="n">u2</span><span class="p">,</span> <span class="n">mesh</span><span class="p">,</span> <span class="p">(</span><span class="n">nx</span><span class="p">,</span><span class="n">ny</span><span class="p">),</span> <span class="n">uniform_mesh</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
</pre></div>
</div>
<p>The function <code class="docutils literal"><span class="pre">dolfin_function2BoxField</span></code> can only work with
finite element fields with <em>linear</em> (degree 1) elements, so for
higher-degree elements we here simply interpolate the solution onto
a mesh with linear elements. We could also
interpolate/project onto a finer mesh in the higher-degree case.
Such transformations to linear finite element fields
are very often needed when calling up plotting packages or data analysis tools.
The <code class="docutils literal"><span class="pre">u.ufl_element()</span></code> method returns an object holding the element
type, and this object has a method <code class="docutils literal"><span class="pre">degree()</span></code> for returning the
element degree as an integer.
The parameters <code class="docutils literal"><span class="pre">nx</span></code> and <code class="docutils literal"><span class="pre">ny</span></code> are the number of divisions in each space
direction that were used when calling <code class="docutils literal"><span class="pre">UnitSquareMesh</span></code> to make the
<code class="docutils literal"><span class="pre">mesh</span></code> object.
The result <code class="docutils literal"><span class="pre">u_box</span></code> is a <code class="docutils literal"><span class="pre">BoxField</span></code>
object that supports &#8220;finite difference&#8221; indexing and an underlying
grid suitable for <code class="docutils literal"><span class="pre">numpy</span></code> operations on 2D data.
Also 1D and 3D meshes (with linear elements) can be turned
into <code class="docutils literal"><span class="pre">BoxField</span></code> objects.</p>
<p>The ability to access a finite element field in the way one can access
a finite difference-type of field is handy in many occasions, including
visualization and data analysis.
Here is an example of writing out the coordinates and the field value
at a grid point with indices <code class="docutils literal"><span class="pre">i</span></code> and <code class="docutils literal"><span class="pre">j</span></code> (going from 0 to
<code class="docutils literal"><span class="pre">nx</span></code> and <code class="docutils literal"><span class="pre">ny</span></code>, respectively, from lower left to upper right corner):</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">X</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">Y</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">Z</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c"># convenient indices</span>

<span class="n">i</span> <span class="o">=</span> <span class="n">nx</span><span class="p">;</span> <span class="n">j</span> <span class="o">=</span> <span class="n">ny</span>   <span class="c"># upper right corner</span>
<span class="k">print</span><span class="p">(</span><span class="s">&#39;u(</span><span class="si">%g</span><span class="s">,</span><span class="si">%g</span><span class="s">)=</span><span class="si">%g</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">u_box</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">coor</span><span class="p">[</span><span class="n">X</span><span class="p">][</span><span class="n">i</span><span class="p">],</span>
                       <span class="n">u_box</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">coor</span><span class="p">[</span><span class="n">Y</span><span class="p">][</span><span class="n">j</span><span class="p">],</span>
                       <span class="n">u_box</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]))</span>
</pre></div>
</div>
<p>For instance,
the <span class="math">\(x\)</span> coordinates are reached by <code class="docutils literal"><span class="pre">u_box.grid.coor[X]</span></code>.
The <code class="docutils literal"><span class="pre">grid</span></code> attribute is an instance of class <code class="docutils literal"><span class="pre">UniformBoxMeshGrid</span></code>.</p>
<p>Many plotting programs can be used to visualize the data in <code class="docutils literal"><span class="pre">u_box</span></code>.
Matplotlib is now a very popular plotting program in the Python world
and could be used to make contour plots of <code class="docutils literal"><span class="pre">u_box</span></code>. However, other
programs like Gnuplot, VTK, and MATLAB have better support for surface
plots at the time of this writing. Our choice in this tutorial is to
use the Python package <code class="docutils literal"><span class="pre">scitools.easyviz</span></code>, which offers a uniform
MATLAB-like syntax as interface to various plotting packages such as
Gnuplot, Matplotlib, VTK, OpenDX, MATLAB, and others. With
<code class="docutils literal"><span class="pre">scitools.easyviz</span></code> we write one set of statements, close to what one
would do in MATLAB or Octave, and then it is easy to switch between
different plotting programs, at a later stage, through a command-line
option, a line in a configuration file, or an import statement in the
program.</p>
<p id="index-70">A contour plot is made by the following <code class="docutils literal"><span class="pre">scitools.easyviz</span></code> command:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">scitools.easyviz</span> <span class="kn">as</span> <span class="nn">ev</span>
<span class="n">ev</span><span class="o">.</span><span class="n">contour</span><span class="p">(</span><span class="n">u_box</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">coorv</span><span class="p">[</span><span class="n">X</span><span class="p">],</span> <span class="n">u_box</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">coorv</span><span class="p">[</span><span class="n">Y</span><span class="p">],</span> <span class="n">u_box</span><span class="o">.</span><span class="n">values</span><span class="p">,</span>
           <span class="mi">5</span><span class="p">,</span> <span class="n">clabels</span><span class="o">=</span><span class="s">&#39;on&#39;</span><span class="p">)</span>
<span class="n">evtitle</span><span class="p">(</span><span class="s">&#39;Contour plot of u&#39;</span><span class="p">)</span>
<span class="n">ev</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="s">&#39;u_contours.pdf&#39;</span><span class="p">)</span>

<span class="c"># or more compact syntax:</span>
<span class="n">ev</span><span class="o">.</span><span class="n">contour</span><span class="p">(</span><span class="n">u_box</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">coorv</span><span class="p">[</span><span class="n">X</span><span class="p">],</span> <span class="n">u_box</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">coorv</span><span class="p">[</span><span class="n">Y</span><span class="p">],</span> <span class="n">u_box</span><span class="o">.</span><span class="n">values</span><span class="p">,</span>
           <span class="mi">5</span><span class="p">,</span> <span class="n">clabels</span><span class="o">=</span><span class="s">&#39;on&#39;</span><span class="p">,</span>
           <span class="n">savefig</span><span class="o">=</span><span class="s">&#39;u_contours.pdf&#39;</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="s">&#39;Contour plot of u&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>The resulting plot can be viewed in
Figure <a class="reference internal" href="#tut-poisson-2d-fig2"><span class="std std-ref">Finite element function on a structured 2D grid: contour plot of the solution (left) and curve plot of the exact flux and the projected numerical flux (right)</span></a> (left).
The <code class="docutils literal"><span class="pre">contour</span></code> function needs arrays with the <span class="math">\(x\)</span> and <span class="math">\(y\)</span> coordinates
expanded to 2D arrays (in the same way as demanded when
making vectorized
<code class="docutils literal"><span class="pre">numpy</span></code> calculations of arithmetic expressions over all grid points).
The correctly expanded arrays are stored in <code class="docutils literal"><span class="pre">grid.coorv</span></code>.
The above call to
<code class="docutils literal"><span class="pre">contour</span></code> creates 5 equally spaced contour lines, and with
<code class="docutils literal"><span class="pre">clabels='on'</span></code> the contour values can be seen in the plot.</p>
<p>Other functions for visualizing 2D scalar fields are <code class="docutils literal"><span class="pre">surf</span></code> and
<code class="docutils literal"><span class="pre">mesh</span></code> as known from MATLAB:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">scitools.easyviz</span> <span class="kn">as</span> <span class="nn">ev</span>
<span class="n">ev</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
<span class="n">ev</span><span class="o">.</span><span class="n">surf</span><span class="p">(</span><span class="n">u_box</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">coorv</span><span class="p">[</span><span class="n">X</span><span class="p">],</span> <span class="n">u_box</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">coorv</span><span class="p">[</span><span class="n">Y</span><span class="p">],</span> <span class="n">u_box</span><span class="o">.</span><span class="n">values</span><span class="p">,</span>
        <span class="n">shading</span><span class="o">=</span><span class="s">&#39;interp&#39;</span><span class="p">,</span> <span class="n">colorbar</span><span class="o">=</span><span class="s">&#39;on&#39;</span><span class="p">,</span>
        <span class="n">title</span><span class="o">=</span><span class="s">&#39;surf plot of u&#39;</span><span class="p">,</span> <span class="n">savefig</span><span class="o">=</span><span class="s">&#39;u_surf.pdf&#39;</span><span class="p">)</span>

<span class="n">ev</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
<span class="n">ev</span><span class="o">.</span><span class="n">mesh</span><span class="p">(</span><span class="n">u_box</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">coorv</span><span class="p">[</span><span class="n">X</span><span class="p">],</span> <span class="n">u_box</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">coorv</span><span class="p">[</span><span class="n">Y</span><span class="p">],</span> <span class="n">u_box</span><span class="o">.</span><span class="n">values</span><span class="p">,</span>
        <span class="n">title</span><span class="o">=</span><span class="s">&#39;mesh plot of u&#39;</span><span class="p">,</span> <span class="n">savefig</span><span class="o">=</span><span class="s">&#39;u_mesh.pdf&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>Figure <a class="reference internal" href="#tut-poisson-2d-fig3"><span class="std std-ref">Finite element function on a structured 2D grid: surface plot of the solution (left) and lifted mesh plot of the solution (right)</span></a> exemplifies
the surfaces arising from
the two plotting commands above.
You can type
<code class="docutils literal"><span class="pre">pydoc</span> <span class="pre">scitools.easyviz</span></code> in a terminal window
to get a full tutorial.
Note that <code class="docutils literal"><span class="pre">scitools.easyviz</span></code> offers function names like
<code class="docutils literal"><span class="pre">plot</span></code> and <code class="docutils literal"><span class="pre">mesh</span></code>, which clash with <code class="docutils literal"><span class="pre">plot</span></code> from <code class="docutils literal"><span class="pre">dolfin</span></code>
and the <code class="docutils literal"><span class="pre">mesh</span></code> variable in our programs. Therefore, we recommend the
<code class="docutils literal"><span class="pre">ev</span></code> prefix.</p>
<p>A handy feature of <code class="docutils literal"><span class="pre">BoxField</span></code> is the ability to give a start point
in the grid and a direction, and then extract the field and corresponding
coordinates along the nearest grid
line. In 3D fields
one can also extract data in a plane.
Say we
want to plot <span class="math">\(u\)</span> along the line <span class="math">\(y=1/2\)</span> in the grid. The grid points,
<code class="docutils literal"><span class="pre">x</span></code>, and the
<span class="math">\(u\)</span> values along this line, <code class="docutils literal"><span class="pre">uval</span></code>, are extracted by</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">start</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">)</span>
<span class="n">x</span><span class="p">,</span> <span class="n">uval</span><span class="p">,</span> <span class="n">y_fixed</span><span class="p">,</span> <span class="n">snapped</span> <span class="o">=</span> <span class="n">u_box</span><span class="o">.</span><span class="n">gridline</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">direction</span><span class="o">=</span><span class="n">X</span><span class="p">)</span>
</pre></div>
</div>
<p>The variable <code class="docutils literal"><span class="pre">snapped</span></code> is true if the line had to be snapped onto a
gridline and in that case <code class="docutils literal"><span class="pre">y_fixed</span></code> holds the snapped
(altered) <span class="math">\(y\)</span> value.
Plotting <span class="math">\(u\)</span> versus the <span class="math">\(x\)</span> coordinate along this line, using
<code class="docutils literal"><span class="pre">scitools.easyviz</span></code>, is now a matter of</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">ev</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>  <span class="c"># new plot window</span>
<span class="n">ev</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">uval</span><span class="p">,</span> <span class="s">&#39;r-&#39;</span><span class="p">)</span>  <span class="c"># &#39;r-: red solid line</span>
<span class="n">ev</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s">&#39;Solution&#39;</span><span class="p">)</span>
<span class="n">ev</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="s">&#39;finite element solution&#39;</span><span class="p">)</span>

<span class="c"># or more compactly:</span>
<span class="n">ev</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">uval</span><span class="p">,</span> <span class="s">&#39;r-&#39;</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="s">&#39;Solution&#39;</span><span class="p">,</span>
        <span class="n">legend</span><span class="o">=</span><span class="s">&#39;finite element solution&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>A more exciting plot compares the projected numerical flux in
<span class="math">\(x\)</span> direction along the
line <span class="math">\(y=1/2\)</span> with the exact flux:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">ev</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
<span class="n">flux2_x</span> <span class="o">=</span> <span class="n">flux_x</span> <span class="k">if</span> <span class="n">flux_x</span><span class="o">.</span><span class="n">ufl_element</span><span class="p">()</span><span class="o">.</span><span class="n">degree</span><span class="p">()</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span> \
          <span class="n">interpolate</span><span class="p">(</span><span class="n">flux_x</span><span class="p">,</span> <span class="n">FunctionSpace</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="s">&#39;Lagrange&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
<span class="n">flux_x_box</span> <span class="o">=</span> <span class="n">scitools</span><span class="o">.</span><span class="n">BoxField</span><span class="o">.</span><span class="n">dolfin_function2BoxField</span><span class="p">(</span>
          <span class="n">flux2_x</span><span class="p">,</span> <span class="n">mesh</span><span class="p">,</span> <span class="p">(</span><span class="n">nx</span><span class="p">,</span><span class="n">ny</span><span class="p">),</span> <span class="n">uniform_mesh</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="n">x</span><span class="p">,</span> <span class="n">fluxval</span><span class="p">,</span> <span class="n">y_fixed</span><span class="p">,</span> <span class="n">snapped</span> <span class="o">=</span> \
          <span class="n">flux_x_box</span><span class="o">.</span><span class="n">gridline</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">direction</span><span class="o">=</span><span class="n">X</span><span class="p">)</span>
<span class="n">y</span> <span class="o">=</span> <span class="n">y_fixed</span>
<span class="n">flux_x_exact</span> <span class="o">=</span> <span class="o">-</span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">)</span><span class="o">*</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span>
<span class="n">ev</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">fluxval</span><span class="p">,</span> <span class="s">&#39;r-&#39;</span><span class="p">,</span>
        <span class="n">x</span><span class="p">,</span> <span class="n">flux_x_exact</span><span class="p">,</span> <span class="s">&#39;b-&#39;</span><span class="p">,</span>
        <span class="n">legend</span><span class="o">=</span><span class="p">(</span><span class="s">&#39;numerical (projected) flux&#39;</span><span class="p">,</span> <span class="s">&#39;exact flux&#39;</span><span class="p">),</span>
        <span class="n">title</span><span class="o">=</span><span class="s">&#39;Flux in x-direction (at y=</span><span class="si">%g</span><span class="s">)&#39;</span> <span class="o">%</span> <span class="n">y_fixed</span><span class="p">,</span>
        <span class="n">savefig</span><span class="o">=</span><span class="s">&#39;flux.pdf&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>As seen from
Figure <a class="reference internal" href="#tut-poisson-2d-fig2"><span class="std std-ref">Finite element function on a structured 2D grid: contour plot of the solution (left) and curve plot of the exact flux and the projected numerical flux (right)</span></a> (right),
the numerical flux
is accurate except in the boundary elements.</p>
<p>The visualization constructions shown above and used to generate the
figures are found in the program <code class="docutils literal"><span class="pre">vcp2D.py</span></code> in the
<code class="docutils literal"><span class="pre">stationary/poisson</span></code> directory.</p>
<div class="figure" id="id8">
<span id="tut-poisson-2d-fig2"></span><a class="reference internal image-reference" href="_images/Poisson2D_Dvc.png"><img alt="_images/Poisson2D_Dvc.png" src="_images/Poisson2D_Dvc.png" style="width: 800px;" /></a>
<p class="caption"><span class="caption-text"><em>Finite element function on a structured 2D grid: contour plot of the solution (left) and curve plot of the exact flux and the projected numerical flux (right)</em></span></p>
</div>
<div class="figure" id="id9">
<span id="tut-poisson-2d-fig3"></span><a class="reference internal image-reference" href="_images/Poisson2D_Dvc_surfmesh1.png"><img alt="_images/Poisson2D_Dvc_surfmesh1.png" src="_images/Poisson2D_Dvc_surfmesh1.png" style="width: 480px;" /></a>
<p class="caption"><span class="caption-text"><em>Finite element function on a structured 2D grid: surface plot of the solution (left) and lifted mesh plot of the solution (right)</em></span></p>
</div>
<p>It should be easy with the information above to transform a finite
element field over a uniform rectangular or box-shaped mesh to the
corresponding <code class="docutils literal"><span class="pre">BoxField</span></code> object and perform MATLAB-style
visualizations of the whole field or the field over planes or along
lines through the domain.  By the transformation to a regular grid we
have some more flexibility than what the <code class="docutils literal"><span class="pre">plot</span></code> command in DOLFIN
offers. However, we remark
that comprehensive tools like VisIt, MayaVi2, or ParaView also have
the possibility for plotting fields along lines and extracting planes
in 3D geometries, though usually with less degree of control compared
to Gnuplot, MATLAB, and Matplotlib.  For example, in investigations of
numerical accuracy or numerical artifacts one is often interested in
studying curve plots where only the nodal values sampled. This is
straightforward with a structured mesh data structure, but more
difficult in visualization packages utilizing unstructured grids, as
hitting exactly then nodes when sampling a function along a line
through the grid might be non-trivial.</p>
</div>
<div class="section" id="combining-dirichlet-and-neumann-conditions">
<span id="tut-poisson1-dn"></span><h2>Combining Dirichlet and Neumann conditions<a class="headerlink" href="#combining-dirichlet-and-neumann-conditions" title="Permalink to this headline">¶</a></h2>
<p>Let us make a slight extension of our two-dimensional Poisson problem
from the section <a class="reference internal" href="#tut-poisson1-bvp"><span class="std std-ref">The Poisson equation</span></a>
and add a Neumann boundary condition. The domain is still
the unit square, but now we set the Dirichlet condition
<span class="math">\(u=u_0\)</span> at the left and right sides,
<span class="math">\(x=0\)</span> and <span class="math">\(x=1\)</span>, while the Neumann condition</p>
<div class="math">
\[-{\partial u\over\partial n}=g\]</div>
<p>is applied to the remaining
sides <span class="math">\(y=0\)</span> and <span class="math">\(y=1\)</span>.
The Neumann condition is also known as a <em>natural boundary condition</em>
(in contrast to an essential boundary condition).</p>
<p id="index-71">Let <span class="math">\(\Gamma_D\)</span> and <span class="math">\(\Gamma_N\)</span>
denote the parts of <span class="math">\(\partial\Omega\)</span> where the Dirichlet and Neumann
conditions apply, respectively.
The complete boundary-value problem can be written as</p>
<div class="math" id="eq-auto13">
\[\tag{30}
- \nabla^2 u = f \mbox{ in } \Omega,\]</div>
<div class="math" id="eq-auto14">
\[\tag{31}
u = u_0 \mbox{ on } \Gamma_D,\]</div>
<div class="math" id="eq-auto15">
\[\tag{32}
- {\partial u\over\partial n} = g \mbox{ on } \Gamma_N  {\thinspace .}\]</div>
<p>Again we choose <span class="math">\(u=1+x^2 + 2y^2\)</span> as the exact solution and adjust <span class="math">\(f\)</span>, <span class="math">\(g\)</span>, and
<span class="math">\(u_0\)</span> accordingly:</p>
<div class="math">
\[\begin{split}f &amp;= -6,\\
g &amp;= \left\lbrace\begin{array}{ll}
-4, &amp; y=1\\
0,  &amp; y=0
\end{array}\right.\\
u_0 &amp;= 1 + x^2 + 2y^2{\thinspace .}\end{split}\]</div>
<p>For ease of programming we may introduce a <span class="math">\(g\)</span> function defined over the whole
of <span class="math">\(\Omega\)</span> such that <span class="math">\(g\)</span> takes on the right values at <span class="math">\(y=0\)</span> and
<span class="math">\(y=1\)</span>. One possible extension is</p>
<div class="math">
\[g(x,y) = -4y{\thinspace .}\]</div>
<p>The first task is to derive the variational problem. This time we cannot
omit the boundary term arising from the integration by parts, because
<span class="math">\(v\)</span> is only zero on <span class="math">\(\Gamma_D\)</span>. We have</p>
<div class="math">
\[ -\int_\Omega (\nabla^2 u)v {\, \mathrm{d}x}
= \int_\Omega\nabla u\cdot\nabla v {\, \mathrm{d}x} - \int_{\partial\Omega}{\partial u\over
\partial n}v {\, \mathrm{d}s},\]</div>
<p>and since <span class="math">\(v=0\)</span> on <span class="math">\(\Gamma_D\)</span>,</p>
<div class="math">
\[- \int_{\partial\Omega}{\partial u\over
\partial n}v {\, \mathrm{d}s}
=
- \int_{\Gamma_N}{\partial u\over
\partial n}v {\, \mathrm{d}s}
= \int_{\Gamma_N}gv {\, \mathrm{d}s},\]</div>
<p>by applying the boundary condition on <span class="math">\(\Gamma_N\)</span>.
The resulting weak form reads</p>
<div class="math" id="eq-tut-poisson-2d-dn-weak">
\[\tag{33}
\int_{\Omega} \nabla u \cdot \nabla v {\, \mathrm{d}x} +
    \int_{\Gamma_N} gv {\, \mathrm{d}s}
    = \int_{\Omega} fv {\, \mathrm{d}x}{\thinspace .}\]</div>
<p>Expressing this equation
in the standard notation <span class="math">\(a(u,v)=L(v)\)</span> is straightforward with</p>
<div class="math" id="eq-tut-poisson2-vard-a">
\[\tag{34}
a(u, v) = \int_{\Omega} \nabla u \cdot \nabla v {\, \mathrm{d}x},\]</div>
<div class="math" id="eq-tut-poisson2-vard-l">
\[\tag{35}
L(v) = \int_{\Omega} fv {\, \mathrm{d}x} -
    \int_{\Gamma_N} gv {\, \mathrm{d}s}{\thinspace .}\]</div>
<p id="index-72">How does the Neumann condition impact the implementation?
Starting with any of the previous files <code class="docutils literal"><span class="pre">d*_p2D.py</span></code>, say
<code class="docutils literal"><span class="pre">d4_p2D.py</span></code>, we realize that the statements remain almost the same.
Only two adjustments are necessary:</p>
<blockquote>
<div><ul class="simple">
<li>The function describing the boundary where Dirichlet conditions
apply must be modified.</li>
<li>The new boundary term must be added to the expression in <code class="docutils literal"><span class="pre">L</span></code>.</li>
</ul>
</div></blockquote>
<p>Step 1 can be coded as</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">Dirichlet_boundary</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">on_boundary</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">on_boundary</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">False</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">False</span>
</pre></div>
</div>
<p>A more compact implementation reads</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">Dirichlet_boundary</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">on_boundary</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">on_boundary</span> <span class="ow">and</span> <span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p>As pointed out already in the section <a class="reference internal" href="#tut-poisson1-impl"><span class="std std-ref">Implementation</span></a>,
testing for an exact match of real numbers is
not good programming practice so we introduce a tolerance in the test:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">Dirichlet_boundary</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">on_boundary</span><span class="p">):</span>
    <span class="n">tol</span> <span class="o">=</span> <span class="mf">1E-14</span>   <span class="c"># tolerance for coordinate comparisons</span>
    <span class="k">return</span> <span class="n">on_boundary</span> <span class="ow">and</span> \
           <span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">&lt;</span> <span class="n">tol</span> <span class="ow">or</span> <span class="nb">abs</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">tol</span><span class="p">)</span>
</pre></div>
</div>
<p>The second adjustment of our program concerns the definition of <code class="docutils literal"><span class="pre">L</span></code>,
where we have to add a boundary integral and a definition of the <span class="math">\(g\)</span>
function to be integrated:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">g</span> <span class="o">=</span> <span class="n">Expression</span><span class="p">(</span><span class="s">&#39;-4*x[1]&#39;</span><span class="p">)</span>
<span class="n">L</span> <span class="o">=</span> <span class="n">f</span><span class="o">*</span><span class="n">v</span><span class="o">*</span><span class="n">dx</span> <span class="o">-</span> <span class="n">g</span><span class="o">*</span><span class="n">v</span><span class="o">*</span><span class="n">ds</span>
</pre></div>
</div>
<p>The <code class="docutils literal"><span class="pre">ds</span></code> variable implies a boundary integral, while <code class="docutils literal"><span class="pre">dx</span></code>
implies an integral over the domain <span class="math">\(\Omega\)</span>.
No more modifications are necessary.</p>
<p>The file <code class="docutils literal"><span class="pre">dn1_p2D.py</span></code> in the <code class="docutils literal"><span class="pre">stationary/poisson</span></code> directory
implements this problem. Running the program verifies the implementation:
<span class="math">\(u\)</span> equals the exact solution at all the nodes,
regardless of how many elements we use.</p>
</div>
<div class="section" id="multiple-dirichlet-conditions">
<span id="tut-poisson-multiple-dirichlet"></span><h2>Multiple Dirichlet conditions<a class="headerlink" href="#multiple-dirichlet-conditions" title="Permalink to this headline">¶</a></h2>
<p>The PDE problem from the previous section applies a function <span class="math">\(u_0(x,y)\)</span>
for setting Dirichlet conditions at two parts of the boundary.
Having a single function to set multiple Dirichlet conditions is
seldom possible. The more general case is to have <span class="math">\(m\)</span> functions for
setting Dirichlet conditions on <span class="math">\(m\)</span> parts of the boundary.
The purpose of this section is to explain how such multiple conditions
are treated in FEniCS programs.</p>
<p id="index-73">Let us
return to the case from the section <a class="reference internal" href="#tut-poisson1-dn"><span class="std std-ref">Combining Dirichlet and Neumann conditions</span></a>
and define two separate functions for
the two Dirichlet conditions:</p>
<div class="math">
\[\begin{split}- \nabla^2 u &amp;= -6 \mbox{ in } \Omega, \\
u &amp;= u_L \mbox{ on } \Gamma_0, \\
u &amp;= u_R \mbox{ on } \Gamma_1, \\
- {\partial u\over\partial n} &amp;= g \mbox{ on } \Gamma_N {\thinspace .}\end{split}\]</div>
<p>Here, <span class="math">\(\Gamma_0\)</span> is the boundary <span class="math">\(x=0\)</span>, while
<span class="math">\(\Gamma_1\)</span> corresponds to the boundary <span class="math">\(x=1\)</span>.
We have that <span class="math">\(u_L = 1 + 2y^2\)</span>, <span class="math">\(u_R = 2 + 2y^2\)</span>, and <span class="math">\(g=-4y\)</span>.
For the left boundary <span class="math">\(\Gamma_0\)</span> we
define
the usual triple of a function for the boundary value,
a function for defining
the boundary of interest, and a <code class="docutils literal"><span class="pre">DirichletBC</span></code> object:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">u_L</span> <span class="o">=</span> <span class="n">Expression</span><span class="p">(</span><span class="s">&#39;1 + 2*x[1]*x[1]&#39;</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">left_boundary</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">on_boundary</span><span class="p">):</span>
    <span class="n">tol</span> <span class="o">=</span> <span class="mf">1E-14</span>   <span class="c"># tolerance for coordinate comparisons</span>
    <span class="k">return</span> <span class="n">on_boundary</span> <span class="ow">and</span> <span class="nb">abs</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">&lt;</span> <span class="n">tol</span>

<span class="n">Gamma_0</span> <span class="o">=</span> <span class="n">DirichletBC</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="n">u_L</span><span class="p">,</span> <span class="n">left_boundary</span><span class="p">)</span>
</pre></div>
</div>
<p>For the boundary <span class="math">\(x=1\)</span> we write a similar code snippet:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">u_R</span> <span class="o">=</span> <span class="n">Expression</span><span class="p">(</span><span class="s">&#39;2 + 2*x[1]*x[1]&#39;</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">right_boundary</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">on_boundary</span><span class="p">):</span>
    <span class="n">tol</span> <span class="o">=</span> <span class="mf">1E-14</span>   <span class="c"># tolerance for coordinate comparisons</span>
    <span class="k">return</span> <span class="n">on_boundary</span> <span class="ow">and</span> <span class="nb">abs</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">tol</span>

<span class="n">Gamma_1</span> <span class="o">=</span> <span class="n">DirichletBC</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="n">u_R</span><span class="p">,</span> <span class="n">right_boundary</span><span class="p">)</span>
</pre></div>
</div>
<p>The various essential conditions are then collected in a list
and used in the solution process:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">bcs</span> <span class="o">=</span> <span class="p">[</span><span class="n">Gamma_0</span><span class="p">,</span> <span class="n">Gamma_1</span><span class="p">]</span>
<span class="o">...</span>
<span class="n">solve</span><span class="p">(</span><span class="n">a</span> <span class="o">==</span> <span class="n">L</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">bcs</span><span class="p">)</span>
<span class="c"># or</span>
<span class="n">problem</span> <span class="o">=</span> <span class="n">LinearVariationalProblem</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">bcs</span><span class="p">)</span>
<span class="n">solver</span>  <span class="o">=</span> <span class="n">LinearVariationalSolver</span><span class="p">(</span><span class="n">problem</span><span class="p">)</span>
<span class="n">solver</span><span class="o">.</span><span class="n">solve</span><span class="p">()</span>
</pre></div>
</div>
<p>In other problems, where the <span class="math">\(u\)</span> values are constant at a part of the
boundary, we may use a simple <code class="docutils literal"><span class="pre">Constant</span></code> object instead of an
<code class="docutils literal"><span class="pre">Expression</span></code> object.</p>
<p>Debugging of PDE solvers very often faces the question of whether the
boundary conditions are set correctly or not. To check which Dirichlet
conditions that are actually set in the present problem, we can call
the <code class="docutils literal"><span class="pre">get_boundary_values</span></code> method in the <code class="docutils literal"><span class="pre">DirichletBC</span></code> objects. This
method returns a dictionary with degrees of freedom as keys and
corresponding  essential conditions as values. In the present
problem we can write</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">coor</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">coordinates</span><span class="p">()</span>
<span class="n">d2v</span> <span class="o">=</span> <span class="n">dof_to_vertex_map</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
<span class="k">for</span> <span class="n">bc</span> <span class="ow">in</span> <span class="n">bcs</span><span class="p">:</span>
    <span class="n">bc_dict</span> <span class="o">=</span> <span class="n">bc</span><span class="o">.</span><span class="n">get_boundary_values</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">dof</span> <span class="ow">in</span> <span class="n">bc_dict</span><span class="p">:</span>
        <span class="k">print</span><span class="p">(</span><span class="s">&#39;dof </span><span class="si">%2d</span><span class="s">: u=</span><span class="si">%g</span><span class="se">\t</span><span class="s"> at point </span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span>
              <span class="p">(</span><span class="n">dof</span><span class="p">,</span> <span class="n">bc_dict</span><span class="p">[</span><span class="n">dof</span><span class="p">],</span>
              <span class="nb">str</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">coor</span><span class="p">[</span><span class="n">d2v</span><span class="p">[</span><span class="n">dof</span><span class="p">]]</span><span class="o">.</span><span class="n">tolist</span><span class="p">()))))</span>
</pre></div>
</div>
<p>The printing of coordinates for each degree of freedom (node here)
is only appropriate when degrees of freedom coincide with function
values at the vertices of the mesh, which is the case for linear
Lagrange elements only. One should therefore make somewhat
more robust code that prints out the coordinates (for convenience
when checking boundary values) only in the case of first-order
Lagrange elements:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">Lagrange_1st_order</span> <span class="o">=</span> <span class="n">V</span><span class="o">.</span><span class="n">ufl_element</span><span class="p">()</span><span class="o">.</span><span class="n">degree</span><span class="p">()</span> <span class="o">==</span> <span class="mi">1</span>
<span class="k">if</span> <span class="n">Lagrange_1st_order</span><span class="p">:</span>
    <span class="n">coor</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">coordinates</span><span class="p">()</span>
    <span class="n">d2v</span> <span class="o">=</span> <span class="n">dof_to_vertex_map</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">bc</span> <span class="ow">in</span> <span class="n">bcs</span><span class="p">:</span>
        <span class="n">bc_dict</span> <span class="o">=</span> <span class="n">bc</span><span class="o">.</span><span class="n">get_boundary_values</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">dof</span> <span class="ow">in</span> <span class="n">bc_dict</span><span class="p">:</span>
            <span class="k">print</span><span class="p">(</span><span class="s">&#39;dof </span><span class="si">%2d</span><span class="s">: u=</span><span class="si">%g</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">dof</span><span class="p">,</span> <span class="n">bc_dict</span><span class="p">[</span><span class="n">dof</span><span class="p">])),</span>
            <span class="k">print</span><span class="p">(</span><span class="s">&#39;</span><span class="se">\t</span><span class="s"> at point </span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span>
                  <span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">coor</span><span class="p">[</span><span class="n">d2v</span><span class="p">[</span><span class="n">dof</span><span class="p">]]</span><span class="o">.</span><span class="n">tolist</span><span class="p">()))))</span>
</pre></div>
</div>
<p>The output for a mesh made by <code class="docutils literal"><span class="pre">UnitSquareMesh(3,</span> <span class="pre">2)</span></code> becomes</p>
<div class="highlight-text"><div class="highlight"><pre>dof  0: u=1      at point (0.0, 0.0)
dof  8: u=3      at point (0.0, 1.0)
dof  4: u=1.5    at point (0.0, 0.5)
dof  3: u=2      at point (1.0, 0.0)
dof 11: u=4      at point (1.0, 1.0)
dof  7: u=2.5    at point (1.0, 0.5)
</pre></div>
</div>
<p>The file <code class="docutils literal"><span class="pre">dn2_p2D.py</span></code> contains a complete program which
demonstrates the constructions above.
An extended example with multiple Neumann conditions would have
been quite natural now, but this requires marking various parts
of the boundary using the mesh function concept and is therefore
left to the section <a class="reference internal" href="._ftut005.html#tut-poisson-mat-neumann"><span class="std std-ref">Multiple Neumann, Robin, and Dirichlet condition</span></a>.</p>
</div>
<div class="section" id="a-linear-algebra-formulation">
<span id="tut-poisson1-linalg"></span><h2>A linear algebra formulation<a class="headerlink" href="#a-linear-algebra-formulation" title="Permalink to this headline">¶</a></h2>
<p>Given <span class="math">\(a(u,v)=L(v)\)</span>, the discrete solution <span class="math">\(u\)</span> is computed by
inserting <span class="math">\(u=\sum_{j=1}^N U_j \phi_j\)</span> into <span class="math">\(a(u,v)\)</span> and demanding
<span class="math">\(a(u,v)=L(v)\)</span> to be fulfilled for <span class="math">\(N\)</span> test functions
<span class="math">\(\hat\phi_1,\ldots,\hat\phi_N\)</span>. This implies</p>
<div class="math">
\[\sum_{j=1}^N a(\phi_j,\hat\phi_i) U_j = L(\hat\phi_i),\quad i=1,\ldots,N,\]</div>
<p>which is nothing but a linear system,</p>
<div class="math">
\[AU = b,\]</div>
<p>where the entries in <span class="math">\(A\)</span> and <span class="math">\(b\)</span> are given by</p>
<div class="math">
\[\begin{split}A_{ij} &amp;= a(\phi_j, \hat{\phi}_i), \\
b_i &amp;= L(\hat\phi_i){\thinspace .}\end{split}\]</div>
<span class="target" id="index-74"></span><span class="target" id="index-75"></span><p id="index-76">The examples so far have specified the left- and right-hand side
of the variational formulation and then asked FEniCS to
assemble the linear system and solve it.
An alternative to is explicitly call functions for assembling the
coefficient matrix <span class="math">\(A\)</span> and the right-side vector <span class="math">\(b\)</span>, and then solve
the linear system <span class="math">\(AU=b\)</span> with respect to the <span class="math">\(U\)</span> vector.
Instead of <code class="docutils literal"><span class="pre">solve(a</span> <span class="pre">==</span> <span class="pre">L,</span> <span class="pre">u,</span> <span class="pre">b)</span></code> we now write</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">A</span> <span class="o">=</span> <span class="n">assemble</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="n">b</span> <span class="o">=</span> <span class="n">assemble</span><span class="p">(</span><span class="n">L</span><span class="p">)</span>
<span class="n">bc</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
<span class="n">u</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
<span class="n">U</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">vector</span><span class="p">()</span>
<span class="n">solve</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">U</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
</pre></div>
</div>
<p>The variables <code class="docutils literal"><span class="pre">a</span></code> and <code class="docutils literal"><span class="pre">L</span></code> are as before. That is, <code class="docutils literal"><span class="pre">a</span></code> refers to the
bilinear form involving a <code class="docutils literal"><span class="pre">TrialFunction</span></code> object (say <code class="docutils literal"><span class="pre">u</span></code>)
and a <code class="docutils literal"><span class="pre">TestFunction</span></code> object (<code class="docutils literal"><span class="pre">v</span></code>), and <code class="docutils literal"><span class="pre">L</span></code> involves a
<code class="docutils literal"><span class="pre">TestFunction</span></code> object (<code class="docutils literal"><span class="pre">v</span></code>). From <code class="docutils literal"><span class="pre">a</span></code> and <code class="docutils literal"><span class="pre">L</span></code>,
the <code class="docutils literal"><span class="pre">assemble</span></code> function can
compute <span class="math">\(A\)</span> and <span class="math">\(b\)</span>.</p>
<p>The matrix <span class="math">\(A\)</span> and vector <span class="math">\(b\)</span> are first assembled without incorporating
essential (Dirichlet) boundary conditions. Thereafter, the
call <code class="docutils literal"><span class="pre">bc.apply(A,</span> <span class="pre">b)</span></code> performs the necessary modifications of
the linear system such that <code class="docutils literal"><span class="pre">u</span></code> is guaranteed to equal the prescribed
boundary values.
When we have multiple Dirichlet conditions stored in a list <code class="docutils literal"><span class="pre">bcs</span></code>,
as explained in the section <a class="reference internal" href="#tut-poisson-multiple-dirichlet"><span class="std std-ref">Multiple Dirichlet conditions</span></a>, we must apply
each condition in <code class="docutils literal"><span class="pre">bcs</span></code> to the system:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c"># bcs is a list of DirichletBC objects</span>
<span class="k">for</span> <span class="n">bc</span> <span class="ow">in</span> <span class="n">bcs</span><span class="p">:</span>
    <span class="n">bc</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
</pre></div>
</div>
<p id="index-77">There is an alternative function <code class="docutils literal"><span class="pre">assemble_system</span></code>, which can
assemble the system and take boundary conditions into account in one call:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">A</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">assemble_system</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">bcs</span><span class="p">)</span>
</pre></div>
</div>
<p>The <code class="docutils literal"><span class="pre">assemble_system</span></code> function incorporates the boundary conditions
in the element matrices and vectors, prior to assembly.
The conditions are also incorporated in a symmetric way to preserve
eventual symmetry of the coefficient matrix.</p>
<p>With <code class="docutils literal"><span class="pre">bc.apply(A,</span> <span class="pre">b)</span></code> the
matrix <code class="docutils literal"><span class="pre">A</span></code> is modified in an nonsymmetric way.</p>
<p>Note that the solution <code class="docutils literal"><span class="pre">u</span></code> is, as before, a <code class="docutils literal"><span class="pre">Function</span></code> object.
The degrees of freedom, <span class="math">\(U=A^{-1}b\)</span>, are filled
into <code class="docutils literal"><span class="pre">u</span></code>&#8216;s <code class="docutils literal"><span class="pre">Vector</span></code> object (<code class="docutils literal"><span class="pre">u.vector()</span></code>)
by the <code class="docutils literal"><span class="pre">solve</span></code> function.</p>
<p>The object <code class="docutils literal"><span class="pre">A</span></code> is of type <code class="docutils literal"><span class="pre">Matrix</span></code>, while <code class="docutils literal"><span class="pre">b</span></code> and
<code class="docutils literal"><span class="pre">u.vector()</span></code> are of type <code class="docutils literal"><span class="pre">Vector</span></code>. We may convert the
matrix and vector data to <code class="docutils literal"><span class="pre">numpy</span></code> arrays by calling the
<code class="docutils literal"><span class="pre">array()</span></code> method as shown before. If you wonder how essential
boundary conditions are incorporated in the linear system, you can
print out <code class="docutils literal"><span class="pre">A</span></code> and <code class="docutils literal"><span class="pre">b</span></code> before and after the
<code class="docutils literal"><span class="pre">bc.apply(A,</span> <span class="pre">b)</span></code> call:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">A</span> <span class="o">=</span> <span class="n">assemble</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="n">b</span> <span class="o">=</span> <span class="n">assemble</span><span class="p">(</span><span class="n">L</span><span class="p">)</span>
<span class="k">if</span> <span class="n">mesh</span><span class="o">.</span><span class="n">num_cells</span><span class="p">()</span> <span class="o">&lt;</span> <span class="mi">16</span><span class="p">:</span>  <span class="c"># print for small meshes only</span>
    <span class="k">print</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">array</span><span class="p">())</span>
    <span class="k">print</span><span class="p">(</span><span class="n">b</span><span class="o">.</span><span class="n">array</span><span class="p">())</span>
<span class="n">bc</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
<span class="k">if</span> <span class="n">mesh</span><span class="o">.</span><span class="n">num_cells</span><span class="p">()</span> <span class="o">&lt;</span> <span class="mi">16</span><span class="p">:</span>
    <span class="k">print</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">array</span><span class="p">())</span>
    <span class="k">print</span><span class="p">(</span><span class="n">b</span><span class="o">.</span><span class="n">array</span><span class="p">())</span>
</pre></div>
</div>
<p>With access to the elements in <code class="docutils literal"><span class="pre">A</span></code> through a <code class="docutils literal"><span class="pre">numpy</span></code> array we can easily
perform computations on this matrix, such as computing the eigenvalues
(using the <code class="docutils literal"><span class="pre">eig</span></code> function in <code class="docutils literal"><span class="pre">numpy.linalg</span></code>). We can alternatively dump
<code class="docutils literal"><span class="pre">A.array()</span></code> and <code class="docutils literal"><span class="pre">b.array()</span></code> to file in MATLAB format and invoke
MATLAB or Octave to analyze the linear system.
Dumping the arrays to MATLAB format is done by</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">scipy.io</span>
<span class="n">scipy</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">savemat</span><span class="p">(</span><span class="s">&#39;Ab.mat&#39;</span><span class="p">,</span> <span class="p">{</span><span class="s">&#39;A&#39;</span><span class="p">:</span> <span class="n">A</span><span class="o">.</span><span class="n">array</span><span class="p">(),</span> <span class="s">&#39;b&#39;</span><span class="p">:</span> <span class="n">b</span><span class="o">.</span><span class="n">array</span><span class="p">()})</span>
</pre></div>
</div>
<p>Writing <code class="docutils literal"><span class="pre">load</span> <span class="pre">Ab.mat</span></code> in MATLAB or Octave will then make
the array variables <code class="docutils literal"><span class="pre">A</span></code> and <code class="docutils literal"><span class="pre">b</span></code> available for computations.</p>
<p id="index-78">Matrix processing in Python or MATLAB/Octave is only feasible for
small PDE problems since the <code class="docutils literal"><span class="pre">numpy</span></code> arrays or matrices in MATLAB
file format are dense matrices. DOLFIN also has an interface to the
eigensolver package SLEPc, which is a preferred tool for computing the
eigenvalues of large, sparse matrices of the type encountered in PDE
problems (see <code class="docutils literal"><span class="pre">demo/la/eigenvalue</span></code> in the DOLFIN source code tree
for a demo).</p>
<p id="index-79">A complete code where the linear system <span class="math">\(AU=b\)</span> is explicitly assembled and
solved is found in the file <code class="docutils literal"><span class="pre">dn3_p2D.py</span></code> in the directory
<code class="docutils literal"><span class="pre">stationary/poisson</span></code>. This code solves the same problem as in
<code class="docutils literal"><span class="pre">dn2_p2D.py</span></code>
(the section <a class="reference internal" href="#tut-poisson-multiple-dirichlet"><span class="std std-ref">Multiple Dirichlet conditions</span></a>).  For small
linear systems, the program writes out <code class="docutils literal"><span class="pre">A</span></code> and <code class="docutils literal"><span class="pre">b</span></code> before and
after incorporation of essential boundary conditions and illustrates
the difference between <code class="docutils literal"><span class="pre">assemble</span></code> and <code class="docutils literal"><span class="pre">assemble_system</span></code>.
The reader is encouraged to run the code for a <span class="math">\(2\times 1\)</span>
mesh (<code class="docutils literal"><span class="pre">UnitSquareMesh(2,</span> <span class="pre">1)</span></code> and study the output of <code class="docutils literal"><span class="pre">A</span></code>.</p>
<p>By default, <code class="docutils literal"><span class="pre">solve(A,</span> <span class="pre">U,</span> <span class="pre">b)</span></code> applies sparse LU decomposition
as solver. Specification of an iterative solver and preconditioner
is done through two optional arguments:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">solve</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">U</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="s">&#39;cg&#39;</span><span class="p">,</span> <span class="s">&#39;ilu&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>Appropriate names of solvers and preconditioners are found in
the section <a class="reference internal" href="._ftut007.html#tut-app-solver-prec"><span class="std std-ref">Linear solvers and preconditioners</span></a>.</p>
<span class="target" id="index-80"></span><p id="index-81">To control tolerances in the stopping criterion and the maximum
number of iterations, one can explicitly form a <code class="docutils literal"><span class="pre">KrylovSolver</span></code> object
and set items in its <code class="docutils literal"><span class="pre">parameters</span></code> attribute
(see also the section <a class="reference internal" href="#tut-poisson1-solver-problem"><span class="std std-ref">Linear variational problem and solver objects</span></a>):</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">solver</span> <span class="o">=</span> <span class="n">KrylovSolver</span><span class="p">(</span><span class="s">&#39;cg&#39;</span><span class="p">,</span> <span class="s">&#39;ilu&#39;</span><span class="p">)</span>
<span class="n">solver</span><span class="o">.</span><span class="n">parameters</span><span class="p">[</span><span class="s">&#39;absolute_tolerance&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1E-7</span>
<span class="n">solver</span><span class="o">.</span><span class="n">parameters</span><span class="p">[</span><span class="s">&#39;relative_tolerance&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1E-4</span>
<span class="n">solver</span><span class="o">.</span><span class="n">parameters</span><span class="p">[</span><span class="s">&#39;maximum_iterations&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1000</span>
<span class="n">u</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
<span class="n">U</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">vector</span><span class="p">()</span>
<span class="n">set_log_level</span><span class="p">(</span><span class="n">DEBUG</span><span class="p">)</span>
<span class="n">solver</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">U</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
</pre></div>
</div>
<p>The program <code class="docutils literal"><span class="pre">dn4_p2D.py</span></code> is a modification of <code class="docutils literal"><span class="pre">dn3_p2D.py</span></code>
illustrating this latter approach.</p>
<p id="index-82">The choice of start vector for the iterations in a linear solver is often
important. With the <code class="docutils literal"><span class="pre">solver.solve(A,</span> <span class="pre">U,</span> <span class="pre">b)</span></code> call the default start vector
is the zero vector. A start vector
with random numbers in the interval <span class="math">\([-100,100]\)</span> can be computed as</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">n</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">vector</span><span class="p">()</span><span class="o">.</span><span class="n">array</span><span class="p">()</span><span class="o">.</span><span class="n">size</span>
<span class="n">U</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">vector</span><span class="p">()</span>
<span class="n">U</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="o">-</span><span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
<span class="n">solver</span><span class="o">.</span><span class="n">parameters</span><span class="p">[</span><span class="s">&#39;nonzero_initial_guess&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">True</span>
<span class="n">solver</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">U</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
</pre></div>
</div>
<p>Note that we must turn off the default behavior of setting the start
vector (&#8220;initial guess&#8221;) to zero.
A random start vector is included in the <code class="docutils literal"><span class="pre">dn4_p2D.py</span></code> code.</p>
<p>Creating the linear system explicitly in a program can have some
advantages in more advanced problem settings. For example, <span class="math">\(A\)</span> may
be constant throughout a time-dependent simulation, so we can avoid
recalculating <span class="math">\(A\)</span> at every time level and save a significant amount
of simulation time.  The sections <a class="reference internal" href="._ftut002.html#tut-timedep-diffusion1-impl"><span class="std std-ref">Implementation</span></a>
and <a class="reference internal" href="._ftut002.html#tut-timedep-diffusion1-noassemble"><span class="std std-ref">Avoiding assembly</span></a> deal with this topic
in detail.</p>
</div>
<div class="section" id="parameterizing-the-number-of-space-dimensions">
<span id="tut-poisson-nd"></span><h2>Parameterizing the number of space dimensions<a class="headerlink" href="#parameterizing-the-number-of-space-dimensions" title="Permalink to this headline">¶</a></h2>
<p id="index-83">FEniCS makes it is easy to write a unified simulation code that can
operate in 1D, 2D, and 3D. We will conveniently make use of this
feature in forthcoming examples.  As an appetizer, go back to the
introductory program <code class="docutils literal"><span class="pre">d1_p2D.py</span></code> in the <code class="docutils literal"><span class="pre">stationary/poisson</span></code> directory
and change the mesh construction from <code class="docutils literal"><span class="pre">UnitSquareMesh(6,</span> <span class="pre">4)</span></code> to
<code class="docutils literal"><span class="pre">UnitCubeMesh(6,</span> <span class="pre">4,</span> <span class="pre">5)</span></code>. Now the domain is the unit cube partitioned into
<span class="math">\(6\times 4\times 5\)</span> boxes, and each box is divided into six
tetrahedra-shaped finite elements for computations.  Run the program
and observe that we can solve a 3D problem without any other
modifications (!). The visualization allows you to rotate the cube and
observe the function values as colors on the boundary.</p>
<p>The forthcoming material introduces some convenient
technicalities such that the same program can run in 1D, 2D, or 3D
without any modifications.
Consider the simple model problem</p>
<div class="math" id="eq-auto16">
\[\tag{36}
u''(x) = 2\hbox{ in }[0,1],\quad u(0)=0,\ u(1)=1,\]</div>
<p>with exact solution <span class="math">\(u(x)=x^2\)</span>. Our aim is to formulate and solve this
problem in a 2D and a 3D domain as well.
We may generalize the domain <span class="math">\([0,1]\)</span> to a rectangle or box of any size
in the <span class="math">\(y\)</span> and <span class="math">\(z\)</span> directions and pose homogeneous Neumann
conditions <span class="math">\(\partial u/\partial n = 0\)</span> at all additional boundaries
<span class="math">\(y=\mbox{const}\)</span> and <span class="math">\(z=\mbox{const}\)</span> to ensure that <span class="math">\(u\)</span> only varies with
<span class="math">\(x\)</span>. For example, let us choose
a unit hypercube as domain: <span class="math">\(\Omega = [0,1]^d\)</span>, where <span class="math">\(d\)</span> is the number
of space dimensions. The generalized <span class="math">\(d\)</span>-dimensional Poisson problem
then reads</p>
<div class="math" id="eq-tut-poisson1-ddim">
\[\begin{split}\tag{37}
\begin{array}{rcll}
        \nabla^2 u  &amp;=  2 &amp;\mbox{in } \Omega, \\
        u  &amp;=  0 &amp;\mbox{on } \Gamma_0,\\
        u  &amp;=  1 &amp;\mbox{on } \Gamma_1,\\
    {\partial u\over\partial n}  &amp;=  0 &amp;\mbox{on } \partial\Omega\backslash\left(
    \Gamma_0\cup\Gamma_1\right),
      \end{array}\end{split}\]</div>
<p>where <span class="math">\(\Gamma_0\)</span> is the side of the hypercube where <span class="math">\(x=0\)</span>, and
where <span class="math">\(\Gamma_1\)</span> is the side where <span class="math">\(x=1\)</span>.</p>
<p id="index-84">Implementing a PDE for any <span class="math">\(d\)</span> is no more
complicated than solving a problem with a specific number of dimensions.
The only non-trivial part of the code is actually to define the mesh.
We use the command line for the user-input to the program. The first argument
can be the degree of the polynomial in the finite element basis functions.
Thereafter, we supply the
cell divisions in the various spatial directions. The number of
command-line arguments will then imply the number of space dimensions.
For example, writing <code class="docutils literal"><span class="pre">3</span> <span class="pre">10</span> <span class="pre">3</span> <span class="pre">4</span></code> on the command line means that
we want to approximate <span class="math">\(u\)</span> by piecewise polynomials of degree 3,
and that the domain is a three-dimensional cube with <span class="math">\(10\times 3\times 4\)</span>
divisions in the <span class="math">\(x\)</span>, <span class="math">\(y\)</span>, and <span class="math">\(z\)</span> directions, respectively.</p>
<p>The Python code can be quite compact:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">degree</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
<span class="n">divisions</span> <span class="o">=</span> <span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span> <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">2</span><span class="p">:]]</span>
<span class="n">d</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">divisions</span><span class="p">)</span>
<span class="n">domain_type</span> <span class="o">=</span> <span class="p">[</span><span class="n">UnitIntervalMesh</span><span class="p">,</span> <span class="n">UnitSquareMesh</span><span class="p">,</span> <span class="n">UnitCubeMesh</span><span class="p">]</span>
<span class="n">mesh</span> <span class="o">=</span> <span class="n">domain_type</span><span class="p">[</span><span class="n">d</span><span class="o">-</span><span class="mi">1</span><span class="p">](</span><span class="o">*</span><span class="n">divisions</span><span class="p">)</span>
<span class="n">V</span> <span class="o">=</span> <span class="n">FunctionSpace</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="s">&#39;Lagrange&#39;</span><span class="p">,</span> <span class="n">degree</span><span class="p">)</span>
</pre></div>
</div>
<p>First note that although <code class="docutils literal"><span class="pre">sys.argv[2:]</span></code> holds the divisions of
the mesh, all elements of the list <code class="docutils literal"><span class="pre">sys.argv[2:]</span></code> are string objects,
so we need to explicitly convert each element to an integer.
The construction <code class="docutils literal"><span class="pre">domain_type[d-1]</span></code> will pick the right name of the
object used to define the domain and generate the mesh.
Moreover, the argument <code class="docutils literal"><span class="pre">*divisions</span></code>
sends all the component of the list <code class="docutils literal"><span class="pre">divisions</span></code> as separate
arguments. For example, in a 2D problem where <code class="docutils literal"><span class="pre">divisions</span></code> has
two elements, the statement</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">mesh</span> <span class="o">=</span> <span class="n">domain_type</span><span class="p">[</span><span class="n">d</span><span class="o">-</span><span class="mi">1</span><span class="p">](</span><span class="o">*</span><span class="n">divisions</span><span class="p">)</span>
</pre></div>
</div>
<p>is equivalent to</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">mesh</span> <span class="o">=</span> <span class="n">UnitSquareMesh</span><span class="p">(</span><span class="n">divisions</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">divisions</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
</pre></div>
</div>
<p>The next part of the program is to set up the boundary conditions.
Since the Neumann conditions have <span class="math">\(\partial u/\partial n=0\)</span> we can
omit the boundary integral from the weak form. We then only
need to take care of Dirichlet conditions at two sides:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">tol</span> <span class="o">=</span> <span class="mf">1E-14</span>   <span class="c"># tolerance for coordinate comparisons</span>
<span class="k">def</span> <span class="nf">Dirichlet_boundary0</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">on_boundary</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">on_boundary</span> <span class="ow">and</span> <span class="nb">abs</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">&lt;</span> <span class="n">tol</span>

<span class="k">def</span> <span class="nf">Dirichlet_boundary1</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">on_boundary</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">on_boundary</span> <span class="ow">and</span> <span class="nb">abs</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">tol</span>

<span class="n">bc0</span> <span class="o">=</span> <span class="n">DirichletBC</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="n">Constant</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">Dirichlet_boundary0</span><span class="p">)</span>
<span class="n">bc1</span> <span class="o">=</span> <span class="n">DirichletBC</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="n">Constant</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="n">Dirichlet_boundary1</span><span class="p">)</span>
<span class="n">bcs</span> <span class="o">=</span> <span class="p">[</span><span class="n">bc0</span><span class="p">,</span> <span class="n">bc1</span><span class="p">]</span>
</pre></div>
</div>
<p>Note that this code is independent of the number of space dimensions.
So are the statements defining and solving
the variational problem:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">u</span> <span class="o">=</span> <span class="n">TrialFunction</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
<span class="n">v</span> <span class="o">=</span> <span class="n">TestFunction</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
<span class="n">f</span> <span class="o">=</span> <span class="n">Constant</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">)</span>
<span class="n">a</span> <span class="o">=</span> <span class="n">inner</span><span class="p">(</span><span class="n">nabla_grad</span><span class="p">(</span><span class="n">u</span><span class="p">),</span> <span class="n">nabla_grad</span><span class="p">(</span><span class="n">v</span><span class="p">))</span><span class="o">*</span><span class="n">dx</span>
<span class="n">L</span> <span class="o">=</span> <span class="n">f</span><span class="o">*</span><span class="n">v</span><span class="o">*</span><span class="n">dx</span>

<span class="n">u</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
<span class="n">solve</span><span class="p">(</span><span class="n">a</span> <span class="o">==</span> <span class="n">L</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">bcs</span><span class="p">)</span>
</pre></div>
</div>
<p>The complete code is found in the file <code class="docutils literal"><span class="pre">paD.py</span></code> (Poisson problem in &#8220;anyD&#8221;).</p>
<p>If we want to parameterize the direction in which <span class="math">\(u\)</span> varies, say by
the space direction number <code class="docutils literal"><span class="pre">e</span></code>, we only need to replace <code class="docutils literal"><span class="pre">x[0]</span></code> in the
code by <code class="docutils literal"><span class="pre">x[e]</span></code>. The parameter <code class="docutils literal"><span class="pre">e</span></code> could be given as a second
command-line argument.  The reader is encouraged to perform this
modification.</p>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
<div class="wrapper">
  <div class="footer">
    <div class="footer-nav">
      <div class="span-6">
	<h4>Usage documentation</h4>
	<ul>
	  <li><a href="http://fenicsproject.org/documentation/tutorial/">Tutorial</a></li>
	  <li><a href="http://fenicsproject.org/documentation/dolfin/dev/python/">Python API</a></li>
	  <li><a href="http://fenicsproject.org/documentation/dolfin/dev/cpp/">C++ API</a></li>
          <li><a href="http://fenicsproject.org/releases/">Release notes</a></li>
	</ul>
      </div>
      <div class="span-6">
	<h4>Developer resources</h4>
	<ul>
	  <li><a href="http://fenicsproject.org/buildbot/">Buildbot</a></li>
	  <li><a href="http://fenicsproject.org/benchbot/">Benchbot</a></li>
	  <li><a href="http://fenicsproject.org/support/launchpad_pages.html">FEniCS on Launchpad</a></li>
	</ul>
      </div>
      <div class="span-6 last">
	<h4>Search this site</h4>
	<div id="searchbox">
	  <form class="search" action="/search.html" method="get">
	    <input type="text" name="q" size="18" />
	    <input type="submit" value="Go" />
	    <input type="hidden" name="check_keywords" value="yes" />
	    <input type="hidden" name="area" value="default" />
	  </form>
	</div>
      </div>
    </div>
    &copy; <a href="http://fenicsproject.org/">The FEniCS Project</a>. (<a href="http://fenicsproject.org/disclaimer.html">Disclaimer</a>)
  </div>
</div>

  </body>
</html>